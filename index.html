<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>目光呆滞的5741号代码搬运工</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="hisaige" />






<meta name="generator" content="Hugo 0.57.2" />


<link rel="canonical" href="https://hisaige.github.io/" />
<link href="%7balternate%20%7bRSS%20application/rss&#43;xml%20%20index%20alternate%20%20false%20false%20true%20false%20false%200%7d%20/index.xml%20https://hisaige.github.io/index.xml%7d" rel="alternate" type="application/rss+xml" title="目光呆滞的5741号代码搬运工" />



<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.af20b78e95c84de86b00a0242a4a77bd2601700e1b250edf27537d957ac0041d.css" integrity="sha256-ryC3jpXITehrAKAkKkp3vSYBcA4bJQ7fJ1N9lXrABB0=" media="screen" crossorigin="anonymous">




<link rel="stylesheet" href="/css/hisaige.css">


<meta property="og:title" content="目光呆滞的5741号代码搬运工" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hisaige.github.io/" />

<meta property="og:updated_time" content="2019-11-15T00:00:00+00:00" />
<meta itemprop="name" content="目光呆滞的5741号代码搬运工">
<meta itemprop="description" content="">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="目光呆滞的5741号代码搬运工"/>
<meta name="twitter:description" content=""/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">目光呆滞的5741号代码搬运工</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/">This is Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      目光呆滞的5741号代码搬运工
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item active">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/">This is Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://hisaige.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          
<section id="posts" class="posts">
  
  
    
  
  
  
    <article class="post bg-white">
  <header class="post-header">
    <h1 class="post-title">
      
        <span class="post-pinned">
          <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  width="32" height="32">
  <path d="M682.666667 512V170.666667h42.666666V85.333333H298.666667v85.333334h42.666666v341.333333l-85.333333 85.333333v85.333334h221.866667v256h68.266666v-256H768v-85.333334l-85.333333-85.333333z"></path>
</svg>

        </span>
      
      <a class="post-link" href="/post/docs/jane-theme-preview.zh-cn/">hisaige~啊呜~嗷哩个嗷@#￥%</a>
    </h1>
    
    <div class="post-meta">
      <time datetime="2019-09-01" class="post-time">
        2019-09-01
      </time>
      <div class="post-category">
          <a href="https://hisaige.github.io/categories/shortcodes/"> shortcodes </a>
          <a href="https://hisaige.github.io/categories/index/"> index </a>
          
        </div>
      <span class="more-meta"> 0 words </span>
      <span class="more-meta"> 0 min read </span>
      
      
      
    </div>
  </header>
  
  <div class="post-content">
    
    <div class="post-summary">
      <p><img src="../../../imgs/jfjh.jpg" alt="jfjh" /></p>

    </div>
    
  </div>
</article>

  
    <article class="post bg-white">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/post/docs/yapi%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/">YAPI部署指南</a>
    </h1>
    
    <div class="post-meta">
      <time datetime="2019-11-15" class="post-time">
        2019-11-15
      </time>
      <div class="post-category">
          <a href="https://hisaige.github.io/categories/docs/"> docs </a>
          
        </div>
      <span class="more-meta"> 1411 words </span>
      <span class="more-meta"> 3 min read </span>
      
      
      
    </div>
  </header>
  
  <div class="post-content">
    
    <div class="post-summary">
      

<h1 align="center">
    windows下node+mongodb+yapi安装教程
</h1>

<h1 id="1-安装node">1. 安装node</h1>

<h2 id="1-1-登陆-node官网-https-nodejs-org-en-download-nodejs-下载windows解压版压缩包">1.1 登陆<a href="https://nodejs.org/en/download//" title="nodeJs">node官网</a>下载windows解压版压缩包</h2>

<h2 id="1-2-将node解压后的目录配置到环境变量">1.2 将node解压后的目录配置到环境变量</h2>

<p>​   <img src="E:桌面文件备份笔记文档imgsnode环境变量.bmp" alt="node环境变量" /></p>

<h2 id="1-3-查看安装版本">1.3 查看安装版本</h2>

<p>​   <img src="E:桌面文件备份笔记文档imgsnode查看安装版本.bmp" alt="node查看安装版本" /></p>

<h2 id="1-4-配置node">1.4 配置node</h2>

<ol>
<li><p>安装目录下新建两个文件夹node-cache 和node-global. 注意安装路径不要有空格</p></li>

<li><p>运行如下命令配置,即配置完毕</p>

<pre><code class="language-yml">npm config set cache &quot;E:\nodeInstall\node-v10.15.3-win-x64\node-cache&quot;
npm config set prefix &quot;E:\nodeInstall\node-v10.15.3-win-x64\node-global&quot;
</code></pre></li>
</ol>

<h2 id="1-5-安装pm2-pm2是运行node程序的强大插件">1.5 安装PM2，PM2是运行node程序的强大插件</h2>

<pre><code class="language-java">npm install pm2@latest -g
</code></pre>

<p>安装完后配置环境变量，将node-global目录配置到path中即可。</p>

<h2 id="1-6-pm2启动">1.6 PM2启动</h2>

<pre><code class="language-java">//PM2启动yapi指令：
pm2 start server/app.js --watch
//PM2关闭yapi指令
pm2 stop server/app.js --watch
</code></pre>

<p><code>--watch</code> 方式启动yapi，永久守护这个yapi进程，避免服务不稳定网站挂掉。</p>

<h1 id="2-安装mongodb">2. 安装mongoDB</h1>

<h2 id="2-1-到-mongodb官网-https-www-mongodb-com-download-center-community-mongodb官网-下载mongodb压缩版安装包">2.1 到<a href="https://www.mongodb.com/download-center/community" title="mongoDB官网">mongoDB官网</a> 下载mongoDB压缩版安装包</h2>

<h2 id="2-2-配置mongodb环境变量">2.2 配置mongoDB环境变量</h2>

<p>​   <img src="E:桌面文件备份笔记文档imgsmongoDB配置环境变量.bmp" alt="" /></p>

<h2 id="2-3-mongodb配置">2.3 mongoDB配置,</h2>

<p>在bin目录下新增mongoDB配置文件<code>mongo.conf</code></p>

<pre><code class="language-yml">dbpath=D:\Program Files\mongodb\mongodb4.0.6\MongoDBData  #数据库路径  

logpath=D:\Program Files\mongodb\mongodb4.0.6\mongo.log #日志输出文件路径

logappend=true #错误日志采用追加模式                                                

journal=true #启用日志文件，默认启用  

quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false  

port=27017 #端口号 默认为2701
</code></pre>

<p>运行CMD, 输入<code>mongod --config &quot;D:\Program Files\mongodb\mongodb4.0.6\bin\mongo.conf&quot; --install --serviceName &quot;MongoDB&quot;</code>将mongoDB安装到服务，启动服务，在浏览器输入localhost:27017如果出现以下信息即表示安装成功。</p>

<pre><code class="language-txt">It looks like you are trying to access MongoDB over HTTP on the native driver port.
</code></pre>

<h2 id="2-4-配置mongodb数据库用户">2.4 配置mongoDB数据库用户</h2>

<p>打开命令行</p>

<pre><code># 1. #启动MONGDB服务
# 2. 运行命令行
C:\Users\chenyj&gt; mongo
 use admin   #切换到admin数据库
switched to db admin
#创建dba用户
db.createUser(
...    {
...      user: &quot;root&quot;,
...      pwd: &quot;infinova1&quot;,
...      roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]
...    }
...  )
#创建yapi数据库
use yapi
switched to db yapi
给yapi数据库添加test1用户,权限为读写
 db.createUser(
...     {
...       user: &quot;yapi&quot;,
...       pwd: &quot;infinova&quot;,
...       roles: [
...          { role: &quot;readWrite&quot;, db: &quot;yapi&quot; }  
...       ]
...     }
... )

</code></pre>

<h1 id="3-安装yapi">3. 安装yapi</h1>

<h2 id="3-1下载yapi">3.1下载yapi</h2>

<pre><code class="language-bash">mkdir yapi
cd yapi
git clone https://github.com/YMFE/yapi.git vendors //或者下载 zip 包解压到 vendors 目录（clone 整个仓库大概 140+ M，可以通过 `git clone --depth=1 https://github.com/YMFE/yapi.git vendors` 命令减少，大概 10+ M）
cp vendors/config_example.json ./config.json //复制完成后请修改相关配置
cd vendors
npm install --production --registry https://registry.npm.taobao.org
npm run install-server //安装程序会初始化数据库索引和管理员账号，管理员账号名可在 config.json 配置
</code></pre>

<h2 id="3-2-配置yapi">3.2 配置yapi</h2>

<p>打开yapi目录，新建 config.json文件如下</p>

<pre><code class="language-json">{
  &quot;port&quot;: &quot;*****&quot;,
  &quot;adminAccount&quot;: &quot;********&quot;,
  &quot;db&quot;: {...},
  &quot;mail&quot;: {
    &quot;enable&quot;: true,
    &quot;host&quot;: &quot;smtp.*.com&quot;,    //邮箱服务器
    &quot;port&quot;: 465,               //端口
    &quot;from&quot;: &quot;***@szinfinova.com&quot;,     //发送人邮箱
    &quot;auth&quot;: {
        &quot;user&quot;: &quot;***@szinfinova.com&quot;, //邮箱服务器账号
        &quot;pass&quot;: &quot;*****&quot;        //邮箱服务器密码
    }
  },
  &quot;db&quot;: {
	&quot;servername&quot;: &quot;127.0.0.1&quot;, //配置数据库
	&quot;DATABASE&quot;: &quot;yapi&quot;, //数据库名
	&quot;port&quot;: 27017, //端口
	&quot;user&quot;: &quot;yapi&quot;, //用户名
	&quot;pass&quot;: &quot;infinova&quot;, //密码
	&quot;authSource&quot;: &quot;&quot;
  }
}
</code></pre>

<h2 id="3-3-启动yapi">3.3 启动yapi</h2>

<p>在<code>vendors</code> 目录下新建<code>startup.bat</code>文件，在里面添加内容如下,在启动mongoDB数据库服务后，双击<code>startup.bat</code> 即可启动yapi项目。</p>

<pre><code class="language-yml">node server/app.js
</code></pre>

<h2 id="3-3-pm2启动">3.3 PM2启动</h2>

<h3 id="3-3-1-安装pm2">3.3.1 安装pm2</h3>

<pre><code class="language-node">npm install -g pm2
</code></pre>

<h3 id="3-3-2-pm2配置环境变量">3.3.2  pm2配置环境变量</h3>

<p><img src="E:桌面文件备份笔记文档imgspm2环境变量.bmp" alt="PM2环境变量" /> <img src="E:桌面文件备份笔记文档imgspm2path.bmp" alt="pm2PATH" /></p>

<h3 id="3-3-3-查看pm2版本">3.3.3 查看pm2版本</h3>

<pre><code class="language-node">## 打开CMD命令行 输入
pm2 -v
</code></pre>

<p>​   <img src="E:桌面文件备份笔记文档imgs查看pm2版本.bmp" alt="查看pm2版本" /></p>

<h3 id="3-3-4-pm2启动yapi">3.3.4 pm2启动yapi</h3>

<p>查看1.6</p>

<h1 id="4-安装注意">4. 安装注意</h1>

<ol>
<li>如果安装完node,npm命令无响应，可以删掉<code>C:\Users（用户）\你的用户名\.npmrc</code> 这个文件。</li>
<li>安装路径尽量不要有空格</li>
<li>如果已经存在安装，要部署到其他电脑上，可以将安装好的node文件夹、mongoDB文件夹、yapi文件夹复制到目标环境，运行CMD, 输入<code>mongod --config &quot;D:\Program Files\mongodb\mongodb4.0.6\bin\mongo.conf&quot; --install --serviceName &quot;MongoDB&quot;</code>将mongoDB安装mongoDB服务到新电脑环境（注意路径），配置好mongoDB和node的环境变量，双击startup即可启动yapi。</li>
</ol>

    </div>
    
  </div>
</article>

  
    <article class="post bg-white">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/post/development/springboot%E9%9A%8F%E7%AC%94/">SpringBoot 随笔</a>
    </h1>
    
    <div class="post-meta">
      <time datetime="2019-10-07" class="post-time">
        2019-10-07
      </time>
      <div class="post-category">
          <a href="https://hisaige.github.io/categories/development/"> Development </a>
          
        </div>
      <span class="more-meta"> 8230 words </span>
      <span class="more-meta"> 17 min read </span>
      
      
      
    </div>
  </header>
  
  <div class="post-content">
    
    <div class="post-summary">
      

<p><center><font color=#0099ff size=7 >SpringBoot 随笔</font></center></p>

<h1 id="1-tips">1. tips</h1>

<h2 id="1-1-jsr303数据校验">1.1. JSR303数据校验</h2>

<h2 id="1-2-value-与-configurationproperties-注解">1.2. @Value 与 @ConfigurationProperties 注解</h2>

<table>
<thead>
<tr>
<th>功能</th>
<th>@Value</th>
<th align="center">@ConfigurationProperties</th>
</tr>
</thead>

<tbody>
<tr>
<td>松散绑定</td>
<td>no</td>
<td align="center">yes</td>
</tr>

<tr>
<td>spEL</td>
<td>yes</td>
<td align="center">no</td>
</tr>

<tr>
<td>批量注解</td>
<td>no</td>
<td align="center">yes</td>
</tr>

<tr>
<td>JSR303数据校验</td>
<td>no</td>
<td align="center">yes</td>
</tr>

<tr>
<td>复杂类型（map、set等）</td>
<td>no</td>
<td align="center">yes</td>
</tr>
</tbody>
</table>

<h2 id="1-3-application-properties-application-yml-方式配置文件">1.3. application.properties、application.yml 方式配置文件</h2>

<ol>
<li>application配置</li>
</ol>

<p><img src="C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539496016269.png" alt="perperties配置" /></p>

<ol>
<li><p>yml配置</p>

<pre><code class="language-yml">person:
	name: xujz
	age: 18
	flag: false
	birth: 2001/01/02
	maps: {k1: v1,k2:v2}
	lists: 
		- 111
		- aaa
	man:
		name: pengyg
		age: 30
	socket-address-holder:
       - port: 80
         url: 127.0.0.1
       - port: 90
         url: 10.82.13.241
</code></pre>

<pre><code class="language-java">@Component
@ConfigurationProperties(prefix=&quot;person&quot;)
public class Person {

	private String name;
//	@Value(&quot;${person.age}&quot;) //从环境变量中取值,如要要用@value注解，则应把@ConfigurationProperties注释掉
	private Integer age; 
//	@Value(&quot;true&quot;) //字面量赋值
	private Boolean flag;
	private Date birth;
	private Map&lt;String,Object&gt; maps;
	private List&lt;Object&gt; lists;
	private Set&lt;Object&gt; sets;
	private Man man;
private List&lt;SocketAddressHolder&gt; socketAddressHolder;
}
</code></pre></li>
</ol>

<h2 id="1-4-propertysource">1.4. @PropertySource</h2>

<p>当配置文件与springboot的系统配置没有太大关系时，可以将配置单独提取出来，避免application.properties文件过大导致后期不好维护</p>

<p>如person.properties文件中配置如下</p>

<pre><code class="language-xml">#person配置
person.name = pengz
person.age = 18
person.flag = false
person.birth = 1993/01/02
person.map.k1 = 1111
person.map.k2 = 2222
person.lists = 1, 2, 3, 4, 5, 6,7 ,8, 9
person.sets = cat, dog, pig
person.man.sex = male
</code></pre>

<p>对于的javaBean类</p>

<pre><code class="language-java">@Component
@PropertySource(value=&quot;classpath:person.properties&quot;) //形式1，用@Value取值
/**
*形式2，可加载多个配置文件
*@PropertySource(value= {&quot;classpath:person.properties&quot;，&quot;classpath:person2.properties&quot;})//用@Value取值
*
*@ConfigurationProperties(prefix=&quot;person&quot;)//形式3.利用springboot特性从*.application取
*值，无需@Value取值
*/
public class Person2 {

	private String name;
//	@Value(&quot;${person.age}&quot;) //从环境变量中取值
	private Integer age; 
//	@Value(&quot;true&quot;) //字面量赋值
	private Boolean flag;
	private Date birth;
	private Map&lt;String,Object&gt; maps;
	private List&lt;Object&gt; lists;
	private Set&lt;Object&gt; sets;
	private Man man;
}
</code></pre>

<h2 id="1-5-配置文件中的占位符">1.5. 配置文件中的占位符</h2>

<p>random.int  、random.long  、random.value  、random.uuid</p>

<pre><code class="language-xml">#person配置
person.name = pengz${random.int}
person.age = 18
person.flag = false
person.birth = 1993/01/02
person.map.k1 = 1111
person.map.k2 = 2222
person.lists = 1, 2, 3, 4, 5, 6,7 ,8, 9
person.sets = cat, dog, pig, ${person.name}
person.man.sex = male
</code></pre>

<p>打印person结果如下</p>

<pre><code class="language-sql">Persion [name=pengz613728050, age=18, flag=false, birth=Sat Jan 02 00:00:00 CST 1993, maps=null, lists=[1, 2, 3, 4, 5, 6, 7, 8, 9], sets=[cat, dog, pig, pengz1619328081], man=Man [sex=male]]
</code></pre>

<h2 id="1-6-配置profile">1.6. 配置profile</h2>

<p>默认情况下配置文件生效的是application.properties</p>

<p>但是我们可以利用profile的特性选择使相应的配置文件生效</p>

<h3 id="1-6-1-对于-properties文件">1.6.1 对于*.properties文件</h3>

<p>如有三个配置文件,<strong>注意其中的命名规则</strong>：</p>

<p>​   <img src="C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539503756153.png" alt="配置文件" /></p>

<p>它们的配置文件分别为</p>

<p>application: server.port = 8081</p>

<p>application-dev: server.port = 8082</p>

<p>application-prod: server.port = 8083</p>

<p>默认情况下 server.port = 8081生效</p>

<p><strong>但是，如果在application.properties中作如下配置</strong></p>

<pre><code class="language-xml">server.port = 8081
spring.profiles.active = prod
</code></pre>

<p>则<code>server.port = 8083</code>生效</p>

<h3 id="1-6-2-对于-yml文件">1.6.2 对于*.yml文件</h3>

<p>yml文件的配置方式如下，<strong>注意: 如果存在 <code>*.properties 文件</code>， <code>*.properties 文件</code>为准</strong></p>

<pre><code class="language-xml">server:
  port: 8081
spring:
  profiles:
    active: prod
---
server:
  port: 8082
spring:
  profiles: dev
  
---
server:
  port: 8083
spring:
  profiles: prod
</code></pre>

<h3 id="1-6-3-在项目已经打包好后-如果有需要改变配置-可以用命令行的方式">1.6.3 在项目已经打包好后，如果有需要改变配置，可以用命令行的方式</h3>

<pre><code class="language-sql">java -jar 打包名 --springboot.profiles.active=dev
</code></pre>

<h2 id="1-7-配置文件加载位置">1.7. 配置文件加载位置</h2>

<p>配置文件所在的位置存在优先级，高优先级的配置文件会覆盖低优先级的配置文件</p>

<pre><code class="language-xml">file:./config &lt;!-- 优先级1 ，项目根目录下的config文件夹--&gt;
file:./
classpath:./config
classpath:./ &lt;!-- 优先级4 --&gt;
</code></pre>

<h2 id="1-8-常用注解">1.8 常用注解</h2>

<h3 id="1-8-1-smartinitializingsingleton">1.8.1 SmartInitializingSingleton</h3>

<p><strong>所有非lazy单例Bean实例化完成后，会调用该方法</strong></p>

<h3 id="1-8-2-常用校验注解">1.8.2 常用校验注解</h3>

<pre><code class="language-java">@NotEmpty 用在集合类上面
@NotBlank 用在String上面
@NotNull 用在八大基本类型及其包装类上

@Valid 基本校验注解
@Validated 功能稍微强大点，可以根据分组校验特定的字段， 如在添加数据时校验groups = { AddValidate.class}，更新数据时校验groups = { setValidate.class}的字段

</code></pre>

<h3 id="1-8-3-dependson-依赖加载">1.8.3 DependsOn 依赖加载</h3>

<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean(initMethod = &quot;initialize&quot;)
    @DependsOn(&quot;eventListener&quot;)
    public EventPublisherBean eventPublisherBean () {
        return new EventPublisherBean();
    }

    @Bean(name = &quot;eventListener&quot;, initMethod = &quot;initialize&quot;)
    // @Lazy
    public EventListenerBean eventListenerBean () {
        return new EventListenerBean();
    }

    public static void main (String... strings) {
        new AnnotationConfigApplicationContext(AppConfig.class);
    }
}

//初始化顺序  eventListener --&gt; eventPublisherBean
</code></pre>

<h2 id="1-9常用类">1.9常用类</h2>

<p><code>HttpHeaderNames</code> ：http请求头里包含的种类名字</p>

<h2 id="1-10-根据注解获取类名再实例化技巧">1.10 根据注解获取类名再实例化技巧</h2>

<pre><code class="language-java">        if (context != null) {
            String[] endpointBeanNames = context.getBeanNamesForAnnotation(ServerEndpoint.class);
            for (String beanName : endpointBeanNames) {
                endpointClasses.add(context.getType(beanName));
            }
        }

        for (Class&lt;?&gt; endpointClass : endpointClasses) {
            registerEndpoint(endpointClass);
        }
</code></pre>

<h2 id="1-11获取类路径的几种方式">1.11获取类路径的几种方式</h2>

<pre><code class="language-java">import java.io.File;
 import java.io.IOException;
 import java.net.URL;

 public class URLDemo {

     
     public static void main(String[] args) {
         URLDemo muDemo = new URLDemo();
         try {
             muDemo.showURL();
         } catch (IOException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
         }
     }

     public void showURL() throws IOException {

         // 第一种：获取类加载的根路径   D:\git\daotie\daotie\target\classes
         File f = new File(this.getClass().getResource(&quot;/&quot;).getPath());
         System.out.println(f);

         // 获取当前类的所在工程路径; 如果不加“/”  获取当前类的加载目录  D:\git\daotie\daotie\target\classes\my
         File f2 = new File(this.getClass().getResource(&quot;&quot;).getPath());
         System.out.println(f2);

         // 第二种：获取项目路径    D:\git\daotie\daotie
         File directory = new File(&quot;&quot;);// 参数为空
         String courseFile = directory.getCanonicalPath();
         System.out.println(courseFile);

 
         // 第三种：  file:/D:/git/daotie/daotie/target/classes/
         URL xmlpath = this.getClass().getClassLoader().getResource(&quot;&quot;);
         System.out.println(xmlpath);

 
         // 第四种： D:\git\daotie\daotie
         System.out.println(System.getProperty(&quot;user.dir&quot;));
         /*
          * 结果： C:\Documents and Settings\Administrator\workspace\projectName
          * 获取当前工程路径
          */

         // 第五种：  获取所有的类路径 包括jar包的路径
         System.out.println(System.getProperty(&quot;java.class.path&quot;));

     }
 }
</code></pre>

<h2 id="1-12-利用接口控制系统初始化">1.12 利用接口控制系统初始化</h2>

<ol>
<li><p>定义<code>SystemInit</code>接口</p>

<pre><code class="language-java">//接口实现方法里面推荐用try-catch,捕获异常，并打印日志
public interface SystemInit {
   
	void init() throws Exception;
   
	void unInit() throws Exception;
}
   
</code></pre></li>

<li><p>定义<code>CacheInit</code>接口继承<code>SystemInit</code>接口</p>

<pre><code class="language-java">public interface CacheInit&lt;T&gt; extends SystemInit {
   
	Map&lt;String,T&gt; getCache() throws Exception;
   	
}
</code></pre></li>

<li><p>初始化系统资源</p>

<pre><code class="language-java">@Component
public class TestInit {
   
	@Autowired
	private List&lt;SystemInit&gt; systemInit;
   	
	@PostConstruct
	public void init() {
   		
		systemInit.forEach(action -&gt; {
			action.init();
		});
	}
}
</code></pre></li>
</ol>

<h2 id="1-13-autowired注入时有多个bean可选择的情况">1.13 @Autowired注入时有多个bean可选择的情况</h2>

<p>​   如果配置文件和注解都声明了bean @Autowired注入 如果不用@Qualifier注解说明注入的是哪个bean 那么注入的bean的名字根据@Autowired注解注释的那个变量来判断 而不是默认首字母小写那个</p>

<p>比如 有多个 Haha接口的实现类bean 一个bean的名字叫haha 另一个叫hahaImpl</p>

<p>以下方式注入的是hahaImpl</p>

<pre><code class="language-java">@Autowired
private Haha hahaImpl;  
</code></pre>

<p>如果<code>@Autowired
private Haha hahaImpl;</code> 里面 变量不是hahaImpl 或者  haha  那么就会报错</p>

<h1 id="2-springboot加载beans的方式">2. SpringBoot加载beans的方式</h1>

<h2 id="2-1-importresource">2.1. @ImportResource</h2>

<p>加载spring配置文件的一种方式，该注解用于容器启动类中。</p>

<p>1.在启动类中</p>

<pre><code class="language-java">@SpringBootApplication
@RestController
@EnableAutoConfiguration
@ImportResource(locations = {&quot;classpath:beans.xml&quot;,&quot;classpath:beans2.xml&quot;}) //
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}
}
</code></pre>

<p>2.beans.xml</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

	&lt;bean id=&quot;helloService&quot; class=&quot;com.infinova.demo.service.HelloService&quot;&gt;&lt;/bean&gt;

&lt;/beans&gt;
</code></pre>

<p>3.HelloService.class</p>

<pre><code class="language-java">public class HelloService {
}
</code></pre>

<p>4.测试类中</p>

<pre><code class="language-java">@Autowired
ApplicationContext context;

@Test
public void testBean() {
    System.out.println(context.containsBean(&quot;helloService&quot;)); //输出：true
}
</code></pre>

<h2 id="2-2-configuration">2.2. @Configuration</h2>

<ol>
<li><p>bean配置类，将beans.xml与启动类中的@ImportResource去掉，其他不变,测试类输出结果仍未true</p>

<pre><code class="language-java">@Configuration
public class SpringBootConfig {
	
	@Bean
	public HelloService helloService() {
		return new HelloService();
	}
}
</code></pre></li>
</ol>

<h2 id="2-3-声明bean注解">2.3. 声明bean注解</h2>

<p>​   <img src="C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539501048683.png" alt="声明bean注解" /></p>

<p><strong>额外话：</strong></p>

<p>​   <img src="C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539501108661.png" alt="声明注解" /></p>

<h2 id="2-4-bean的作用域">2.4. bean的作用域</h2>

<p><img src="C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539502143217.png" alt="bean的作用域" /></p>

<h2 id="2-5-import注解">2.5. @Import注解</h2>

<p>value值是一个数组，可以注入三种形式的类</p>

<ol>
<li><strong>普通javabean</strong></li>
<li><strong>ImportSelector</strong></li>
<li><strong>ImportBeanDefinitionRegistrar</strong></li>
</ol>

<p>对于<code>ImportSelector</code></p>

<pre><code class="language-java">public class MyImportSelector implements  ImportSelector{
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{&quot;com.hisaige.bean.MySelector&quot;};
    }
}
</code></pre>

<p>对于<code>ImportBeanDefinitionRegistrar</code></p>

<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar  implements ImportBeanDefinitionRegistrar{
    public void registerBeanDefinitions(
            AnnotationMetadata importingClassMetadata,
            BeanDefinitionRegistry registry) {
        RootBeanDefinition rootBeanDefinition = new 			RootBeanDefinition(Test.class);
        // 注册一个名字叫rectangle的bean
        registry.registerBeanDefinition(&quot;test&quot;, rootBeanDefinition);
    }
}
</code></pre>

<p>配置类中添加注解@import({MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})可以将<code>MySelector.class</code>、<code>Test.class</code>放入spring容器中。</p>

<h2 id="2-6-importselector简单使用">2.6 ImportSelector简单使用</h2>

<pre><code class="language-java">//自定义逻辑返回需要导入的组件
//使用 `@Import(MyImportSelect.class)`将其调用。
public class MyImportSelect implements ImportSelector {

	//返回值，就是到导入到容器中的组件全类名
	//AnnotationMetadata:当前标注@Import注解的类的所有注解信息
	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		//importingClassMetadata包含所有注解信息
		
		//不能反回null值
		return new String[] {ImportBean.class.getName()};
	}
	
}
</code></pre>

<h2 id="2-7-importaware简单使用">2.7 @ImportAware简单使用</h2>

<ol>
<li><p>定义配置类，继承ImportAware接口</p>

<pre><code class="language-java">@Configuration
@EnableConfigurationProperties(Person.class) //很重要，不然会报错说找不到Person这个bean
public class MyImportAwareConfig implements ImportAware {
   
	@Autowired
   private Person person;
   	
	@Override
	public void setImportMetadata(AnnotationMetadata importMetadata) {
	//importMetadata 可以获取注解信息	
		System.out.println(importMetadata.getAnnotationTypes());
		System.out.println(person.getName());
	}
   	
	/*
	 * @Bean public Test getTest() { Test test = new Test(); return test; }
	 */
   
}
</code></pre></li>

<li><p>定义Person类,当然这个类和@ImportAware的使用并没有太多关系</p>

<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;springboot.person&quot;)
public class Person {
   
	private String name;;
	private Integer age;
	private String sex;
	...setter and getter...
</code></pre></li>

<li><p>定义我们自己的注解</p>

<pre><code class="language-java">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
@Target(value = { java.lang.annotation.ElementType.TYPE })
@Documented
@Import({ MyImportAwareConfig.class })
@Configuration
public @interface EnableDemo {
   String param() default &quot;&quot;;
}
   
</code></pre></li>

<li><p>使用我们自己的注解</p>

<pre><code class="language-java">@EnableDemo(param=&quot;aa&quot;)
public class Test {
   
}
</code></pre></li>

<li><p>配置文件信息</p>

<pre><code class="language-yml">springboot: 
 person:
   name: jz
   sex: male
   age: 20
</code></pre></li>

<li><p>运行结果打印如下</p>

<pre><code class="language-text">{param=[aa]}
[spring.boot.aware.EnableDemo]
jz
</code></pre></li>
</ol>

<h2 id="2-8-embeddedvalueresolveraware">2.8 EmbeddedValueResolverAware</h2>

<p>valueResolver可以解析环境变量中的字符串, 示例如下</p>

<pre><code class="language-java">@PropertySource(&quot;classpath:/dbconfig.properties&quot;)
@Configuration
public class MainConfigOfProfile implements EmbeddedValueResolverAware{
    @Override
	public void setEmbeddedValueResolver(StringValueResolver resolver) {
		// TODO Auto-generated method stub
		this.valueResolver = resolver;
		driverClass = valueResolver.resolveStringValue(&quot;${db.driverClass}&quot;);
	}
</code></pre>

<h2 id="2-9-项目启动时排除某个bean或某个自动装配">2.9 项目启动时排除某个bean或某个自动装配</h2>

<pre><code class="language-java">// 在启动类的@EnableAutoConfiguration或@SpringBootApplication后添加(exclude = //{DataSourceAutoConfiguration.class})，排除此类的autoconfig。启动以后就可以正常运行。
//如：
@EnableAutoConfiguration(exclude = {SecurityAutoConfiguration.class })
//或
@SpringBootApplication(exclude = {SecurityAutoConfiguration.class })
</code></pre>

<h1 id="3-自定义startter">3. 自定义startter</h1>

<h2 id="3-1">3.1</h2>

<h1 id="4-aop">4.AOP</h1>

<h2 id="4-1-execution表达式">4.1 execution表达式</h2>

<p><img src=".imgsexecution表达式.bmp" alt="" /></p>

<p>execution：用于匹配方法执行的连接点；</p>

<p>​         within：用于匹配指定类型内的方法执行；</p>

<p>​         this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；</p>

<p>​         target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；</p>

<p>​         args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；</p>

<p>​         @within：用于匹配所以持有指定注解类型内的方法；</p>

<p>​         @target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；</p>

<p>​         @args：用于匹配当前执行的方法传入的参数持有指定注解的执行；</p>

<p>​         @annotation：用于匹配当前执行方法持有指定注解的方法；</p>

<ul>
<li><p>execution()
表达式结构：</p>

<pre><code class="language-java">execution(&lt;修饰符&gt;? &lt;返回类型&gt; &lt;包名&gt;?&lt;方法名&gt;(&lt;参数&gt;)异常?)
execution(
  modifier-pattern?
  returnType-pattern
  package-pattern?
  methodName-pattern(args-pattern)
  throwException-pattern?
)
execution(*[修饰符]? *[返回值] *[包路径]?*[方法名](..[参数])throw *[异常类]?)
</code></pre></li>

<li><p>修饰符匹配(modifier-pattern)</p>

<pre><code class="language-java">1.修饰符匹配(modifier-pattern)
   //匹配所有public修饰的方法
  @Pointcut(&quot;execution(public * **(..))&quot;)
  public void exTest1(){}
2.返回值匹配(returnType-pattern)
   //匹配所有String或者void返回值的方法
  @Pointcut(&quot;execution(String||void **(..))&quot;)
  public void exTest2(){}
3.包路径匹配(package-pattern)
  //com包下的所有类的方法
  @Pointcut(&quot;execution(* com.*.*(..))&quot;)
  public void exTest3(){}
  
  //如果不使用..匹配到了类级别的名字,需要类.方法名.............
  //com包下的所有子包的所有类的方法
  @Pointcut(&quot;execution(* com..*(..))&quot;)
  public void exTest4(){}
  
  //com包下的所有子包的ProductService类的方法
  @Pointcut(&quot;execution(* com..ProductService.*(..))&quot;)
  public void exTest5(){}
  
4.方法名匹配(methodName-pattern)
   //匹配所有test名字开头的方法
  @Pointcut(&quot;execution(* test*(..))&quot;)
  public void exTest6(){}
  
  //匹配所有包含test名字的方法
  @Pointcut(&quot;execution(* *test*(..))&quot;)
  public void exTest7(){}
5.参数匹配(args-pattern)
  //匹配所有参数列表的方法
  @Pointcut(&quot;execution(* *(..))&quot;)
  public void exTest8(){}
  
  //匹配无参数列表的方法
  @Pointcut(&quot;execution(* *())&quot;)
  public void exTest9(){}
6.异常匹配(throwsException-pattern)
  //匹配所有抛过异常的方法
  @Pointcut(&quot;execution(* *()throws *)&quot;)
  public void exTest10(){}
  
  //只匹配所有抛出空指针异常的方法
  @Pointcut(&quot;execution(* *()throws NullPointerException)&quot;)
  public void exTest11(){}
  
</code></pre></li>

<li><h5 id="匹配注解">匹配注解</h5>

<pre><code class="language-java">1.@target()
//匹配所有使用了AspectAnnotation注解的类的所有方法(要求注解的RetentionPolicy的级别为RUNTIME)
  @Pointcut(&quot;@target(com.tiglle.manage.AspectAnnotation)&quot;)
  public void targetMatch(){}
  
2.@args()
//匹配所有使用了AspectAnnotation注解为参数的方法
  @Pointcut(&quot;@args(com.tiglle.manage.AspectAnnotation)&quot;)
  public void argsMatch(){}
3.@within
//匹配所有使用了AspectAnnotation注解的类的所有方法(要求注解的RetentionPolicy的级别为CLASS)
  @Pointcut(&quot;@within(com.tiglle.manage.AspectAnnotation)&quot;)
  public void withinMatch(){}
4.@annotation()
  //方法注解匹配,匹配所有带AspectAnnotation注解的方法
  @Pointcut(&quot;@annotation(com.tiglle.manage.annotation.AspectAnnotation)&quot;)
  public void test(){
  }
  
</code></pre></li>

<li><h5 id="匹配包或者类型">匹配包或者类型</h5>

<pre><code class="language-java">1.within() 如果传的是全类名(包名.类名):匹配此类下所有的方法
  //匹配TestService类中的所有方法
   @Pointcut(&quot;within(com.tiglle.service.TestService)&quot;)
   public voud test(){}
2.within() 如果传的时包名:匹配此包下所有类的方法
//匹配com/tiglle/包下所有包和子包中的类中的所有方法
	@Pointcut(&quot;within(com.tiglle..*)&quot;)
	public voud test(){}
</code></pre></li>

<li><h5 id="匹配对象">匹配对象</h5>

<pre><code class="language-java">1. this()
  //匹配代理对象和普通对象及其所有子类的方法
  @Pointcut(&quot;this(com.tiglle.manage.service.ProductService)&quot;)
  public void thisMatch(){
  }
2.bean()
  //根据spring容器的bean的名称(id)匹配,(不匹配子类)
  @Pointcut(&quot;bean(productService)&quot;)
  public void beanMatch(){
  }
3.target()
  //匹配目标对象和普通对象及其所有子类的方法
  @Pointcut(&quot;target(com.tiglle.manage.service.ProductService)&quot;)
  public void targetMatch(){
  }
  
</code></pre></li>

<li><h5 id="匹配参数">匹配参数</h5>

<pre><code class="language-java">1.args()匹配spring容器所有此参数类型和列表的方法(String,Long)
  //匹配spring容器所有此参数类型和列表的方法(String,Long)
  @Pointcut(&quot;args(String,Long)&quot;)
  public void argsMatch(){}
2.args()匹配spring容器所有此参数类型和列表的方法(第一个为Long,后面随意)
  //匹配spring容器所有此参数类型和列表的方法(第一个为Long,后面随意)
  @Pointcut(&quot;args(Long,..)&quot;)
  public void argsMatch2(){}
</code></pre></li>

<li><p>使用连接符连接切面</p>

<pre><code class="language-java">@Pointcut(&quot;@annotation(com.hisaige.annotation.Enhance) || @within(com.hisaige.annotation.Enhance))&quot;)
	public void pointcut() {
  
	}
</code></pre></li>
</ul>

<h1 id="5-spring常用工具">5. spring常用工具</h1>

<h2 id="5-1-获取父类-接口泛型">5.1 获取父类/接口泛型</h2>

<ol>
<li><p>定义父类或父接口</p>

<pre><code class="language-java">public interface TypeResolverService&lt;T&gt; {
   
	T getStr();
}
</code></pre></li>

<li><p>定义子类</p>

<pre><code class="language-java">public class TypeResolverServiceImpl implements TypeResolverService&lt;String&gt; {
   
	@Override
	public String getStr() {
		// TODO Auto-generated method stub
		return null;
	}
}
   
</code></pre></li>

<li><p>获取泛型信息</p>

<pre><code class="language-java">@SpringBootApplication
public class GenericTypeResolverTest {
	public static void main(String[] args) {
		SpringApplication.run(GenericTypeResolverTest.class, args);
		ResolvableType resolvableType = ResolvableType.forClass(TypeResolverServiceImpl.class).as(TypeResolverService.class);
		boolean flag = resolvableType.hasGenerics();//判断是否有泛型
		if(flag) {
			System.out.println(&quot;T -&gt;&quot; + resolvableType.getGenerics()[0]); //获取第一个泛型信息
		}
	}
}
</code></pre></li>

<li><p>打印结果</p>

<pre><code class="language-java">T -&gt;java.lang.String
</code></pre></li>
</ol>

<h2 id="5-2-resttemplate-工具类">5.2 RestTemplate 工具类</h2>

<ol>
<li><p>解决url中文乱码</p>

<pre><code class="language-java">@Bean(name = &quot;outerRestTemplate&quot;)
   public RestTemplate getRestTemplate(){
       RestTemplate restTemplate = new RestTemplate();
       //解决中文乱码
       restTemplate.getMessageConverters().set(1, new 	 	    		                   StringHttpMessageConverter(StandardCharsets.UTF_8));
       return restTemplate;
   }
</code></pre></li>

<li><p><code>ObjectProvider</code>隐式注入，如以下代码段，messageConverters，restTemplateCustomizers 有则注入，没有就不。spring4.3后才有</p>

<pre><code class="language-java">public RestTemplateConfiguration(
				ObjectProvider&lt;HttpMessageConverters&gt; messageConverters,
				ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers) {
			this.messageConverters = messageConverters;
			this.restTemplateCustomizers = restTemplateCustomizers;
		}
   
</code></pre></li>
</ol>

<h2 id="5-3-resttemplate踩坑记录">5.3 RestTemplate踩坑记录</h2>

<ol>
<li><p>RestTemplate配置</p>

<pre><code class="language-java">//连接属性
@ConfigurationProperties(prefix = &quot;http.config&quot;)
public class HttpClientProperty {
   
	  private int maxTotalConnect; //连接池的最大连接数
	  private int maxConnectPerRoute; //单个主机的最大连接数
	  private int connectTimeout; //连接超时默认2s
	  private int readTimeout; //读取超时默认30s
   ...setter and getter...
</code></pre></li>

<li><p>配置RestTemplate,将RestTemplate加入bean容器</p>

<pre><code class="language-java">@Configuration
@ConditionalOnClass(value = { RestTemplate.class, HttpClient.class })
//如果没有@EnableConfigurationProperties，就必须将HttpClientProperty加入bean容器，如添加@Component注解
@EnableConfigurationProperties(HttpClientProperty.class) 
public class RestTemplateConfiguration {
   
	@Autowired
	private HttpClientProperty httpClientProperty;
   
	// 创建HTTP客户端工厂   @Deprecated 分模块代替
	/*
	 * private ClientHttpRequestFactory createFactory() { if
	 * (httpConfObj.getMaxTotalConnect() &lt;= 0) { SimpleClientHttpRequestFactory
	 * factory = new SimpleClientHttpRequestFactory();
	 * factory.setConnectTimeout(httpConfObj.getConnectTimeout());
	 * factory.setReadTimeout(httpConfObj.getReadTimeout()); return factory; }
	 * HttpClient httpClient =
	 * HttpClientBuilder.create().setMaxConnTotal(httpConfObj.getMaxTotalConnect())
	 * .setMaxConnPerRoute(httpConfObj.getMaxConnectPerRoute()).build();
	 * HttpComponentsClientHttpRequestFactory factory = new
	 * HttpComponentsClientHttpRequestFactory(httpClient);
	 * factory.setConnectTimeout(httpConfObj.getConnectTimeout());
	 * factory.setReadTimeout(httpConfObj.getReadTimeout()); return factory; }
	 */
   
	// 初始化RestTemplate,并加入spring的Bean工厂，由spring统一管理
	@Bean
	@ConditionalOnMissingBean(RestTemplate.class)
	public RestTemplate getRestTemplate(RestTemplateBuilder builder) {
		RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory());
   
		List&lt;HttpMessageConverter&lt;?&gt;&gt; converterList = restTemplate.getMessageConverters();
   
		// 重新设置StringHttpMessageConverter字符集为UTF-8，解决中文乱码问题
		HttpMessageConverter&lt;?&gt; converterTarget = null;
		for (HttpMessageConverter&lt;?&gt; item : converterList) {
			if (StringHttpMessageConverter.class == item.getClass()) {
				converterTarget = item;
				break;
			}
		}
		if (null != converterTarget) {
			converterList.remove(converterTarget);
		}
		converterList.add(1, new StringHttpMessageConverter(StandardCharsets.UTF_8));
   
		//
		/**
		 * 加入FastJson转换器 根据使用情况进行操作，此段注释，默认使用jackson
		 * spring的json转换器默认使用的是Jackson，json字符串和对应的Entity如果有字段对不上就会报错，这点很重要(踩过大坑》。。。)
		 * 如果使用的实体信息比较标准，可以使用jackson，个人使用FastJsonHttpMessageConverter，可以将请求结果直接转成JSONObject
		 */
		converterList.add(new FastJsonHttpMessageConverter());
		return restTemplate;
	}
   
	/**
	 * 配置Http请求转换器
	 * @return
	 */
	@Bean
	@ConditionalOnMissingBean
	public HttpMessageConverters fastjsonConverter() {
		FastJsonConfig fastJsonConfig = new FastJsonConfig();
		// 自定义格式化输出
//		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat, SerializerFeature.WriteNullStringAsEmpty,
//				SerializerFeature.WriteNullNumberAsZero); // 会将null值写成空字符串
		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat, SerializerFeature.WriteNullNumberAsZero);
   
		FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
		// 中文乱码解决方案
       List&lt;MediaType&gt; mediaTypes = new ArrayList&lt;&gt;();
       mediaTypes.add(MediaType.APPLICATION_JSON_UTF8);//设定json格式且编码为UTF-8
       fastJsonHttpMessageConverter.setSupportedMediaTypes(mediaTypes);
   		
       fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);
           
		return new HttpMessageConverters(fastJsonHttpMessageConverter);
	}
   
	@Bean
	@ConditionalOnMissingBean
	public HttpClientConnectionManager poolingConnectionManager() {
		PoolingHttpClientConnectionManager poolingConnectionManager = new PoolingHttpClientConnectionManager();
		poolingConnectionManager.setMaxTotal(1000); // 连接池最大连接数
		poolingConnectionManager.setDefaultMaxPerRoute(100); // 每个主机的并发
		return poolingConnectionManager;
	}
   
	@Bean
	@ConditionalOnMissingBean
	public HttpClientBuilder httpClientBuilder() {
		HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();
		// 设置HTTP连接管理器
		httpClientBuilder.setConnectionManager(poolingConnectionManager());
		return httpClientBuilder;
	}
   
	@Bean
	@ConditionalOnMissingBean
	public ClientHttpRequestFactory clientHttpRequestFactory() {
		if (httpClientProperty.getMaxTotalConnect() &lt;= 0) {
			SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
			factory.setConnectTimeout(httpClientProperty.getConnectTimeout());
			factory.setReadTimeout(httpClientProperty.getReadTimeout());
			return factory;
		} else {
			HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory();
			clientHttpRequestFactory.setHttpClient(httpClientBuilder().build());
			clientHttpRequestFactory.setConnectTimeout(httpClientProperty.getConnectTimeout()); // 连接超时，毫秒
			clientHttpRequestFactory.setReadTimeout(httpClientProperty.getReadTimeout()); // 读写超时，毫秒
			return clientHttpRequestFactory;
		}
	}
}
</code></pre></li>

<li><p>使用RestTemplate,共包含两个请求</p>

<pre><code class="language-java">@Service
public class RestTemplateService {
   
	@Autowired
	private RestTemplate restTemplate;
   	
	public String testRestTemplate() throws UnsupportedEncodingException {
   		
		HttpHeaders headers = new HttpHeaders();
       MediaType type = MediaType.parseMediaType(&quot;application/json; charset=UTF-8&quot;);
       headers.setContentType(type);
       headers.add(&quot;Accept&quot;, &quot;*/*&quot;);
       Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
		map.put(&quot;form_code&quot;, &quot;QuerysDeviceChannels&quot;);
		map.put(&quot;appid&quot;, &quot;123456&quot;);
		map.put(&quot;appsecret&quot;, &quot;123&quot;);
		map.put(&quot;status&quot;, &quot;ALL&quot;);
		map.put(&quot;page_size&quot;, &quot;100&quot;);
		map.put(&quot;page_index&quot;, &quot;1&quot;);
		map.put(&quot;trade_id&quot;, &quot;12314&quot;);
//        RerEntity rerEntity = new RerEntity(&quot;QuerysDeviceChannels&quot;,&quot;123456&quot;, &quot;123&quot;, &quot;ALL&quot;, &quot;100&quot;, &quot;1&quot;, &quot;13214&quot;);
//        String str = &quot;{\n&quot; +  //这样也行，不过麻烦且看起来不友好
//        		&quot;	\&quot;form_code\&quot;:\&quot;QuerysDeviceChannels\&quot;,\n&quot; + 
//        		&quot;	\&quot;appid\&quot;:\&quot;123456\&quot;,\n&quot; + 
//        		&quot;	\&quot;appsecret\&quot;:\&quot;123\&quot;,\n&quot; + 
//        		&quot;	\&quot;status\&quot;:\&quot;ALL\&quot;,\n&quot; + 
//        		&quot;	\&quot;page_size\&quot;:1000,\n&quot; + 
//        		&quot;	\&quot;page_index\&quot;:\&quot;789\&quot;,\n&quot; + 
//        		&quot;	\&quot;trade_id\&quot;:12314\n&quot; + 
//        		&quot;}&quot;;
		HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(JSONObject.toJSON(map).toString(),headers);
		JSONObject json = restTemplate.postForEntity(&quot;http://127.0.0.1:8092/OutDataApi&quot;, entity, JSONObject.class).getBody();
//		ResponseEntity&lt;String&gt; postForEntity = restTemplate.postForEntity(&quot;http://127.0.0.1:8092/OutDataApi&quot;, entity, String.class);
		return json.toString();
	}
   
	public String test2() {
		HttpHeaders headers = new HttpHeaders();
       MediaType type = MediaType.parseMediaType(&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;);
       headers.setContentType(type);
//        headers.add(&quot;Accept&quot;, &quot;*/*&quot;);
		String url = &quot;http://localhost:8099/camera/status&quot;;
//		JSONObject map = new JSONObject(); //这种方式传参，后端也许不能接收
//		map.put(&quot;page&quot;, &quot;1&quot;);
//		map.put(&quot;pageSize&quot;, &quot;50&quot;);
//		map.put(&quot;status&quot;, &quot;off&quot;);
//		map.put(&quot;isShareIdCanBeNull&quot;, &quot;false&quot;);
		MultiValueMap&lt;String, String&gt; requestParam = new LinkedMultiValueMap&lt;&gt;(); //部分情况下，这种方式传参，后端才能接受
		requestParam.set(&quot;page&quot;, &quot;1&quot;);
		requestParam.set(&quot;pageSize&quot;, &quot;50&quot;);
		requestParam.set(&quot;status&quot;, &quot;off&quot;);
		requestParam.set(&quot;isShareIdCanBeNull&quot;, &quot;false&quot;);
//		CameraEntity cameraEntity = new CameraEntity(&quot;1&quot;, &quot;50&quot;, &quot;off&quot;, &quot;false&quot;);
   		
		//如果要设置请求头，就用HttpEntity，不需要设置请求头就直接用请求参数代替HttpEntity
		HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = new HttpEntity&lt;&gt;(requestParam,headers);
		JSONObject json = restTemplate.postForObject(url, entity, JSONObject.class);
		return json.toString();
	}
</code></pre></li>
</ol>

<p><strong>说明</strong>：</p>

<p>1）<code>http://127.0.0.1:8092/OutDataApi</code>这个请求的请求体必须是json格式，controller中请求参数添加<code>@RequestBody</code>注解的http请求</p>

<p>2）<code>http://127.0.0.1:8092/OutDataApi</code>这个请求的controller中请求参数为多个对象组成，如下面接口.如果要设置请求头，应使用<code>HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(requestParam,headers);</code>,如果不设置请求头，则可以直接使用请求对象当参数<code>JSONObject json = restTemplate.postForObject(url, requestParam, JSONObject.class);</code>,其中<code>requestParam</code>必须是<code>MultiValueMap</code>对象。</p>

<p>3）如果需要在返回结果中获取请求状态码、请求头等内容，则可以使用<code>xxxForEntity</code>方式发生请求，如果只需要获取请求返回的结果，则可以使用<code>xxxForObject</code>发生请求。</p>

<pre><code class="language-java">   @ResponseBody
   	@RequestMapping(&quot;/status&quot;)
   	public AjaxMessageResult&lt;Object&gt; getCameraByStatus(
   			@Validated({ SetPageValidate.class, SetStatusValidate.class }) ReqCamera cameraBo, ReqPage reqPage, BindingResult result) throws Exception {
   		if (result.hasErrors()) {
   			return new AjaxInvalidResult(result);
   		}
           ......
</code></pre>

<h2 id="5-4-http请求转化器">5.4 HTTP请求转化器</h2>

<pre><code class="language-java">/**
	 * 配置Http请求转换器
	 * @return
	 */
	@Bean
	@ConditionalOnMissingBean
	public HttpMessageConverters fastjsonConverter() {
		FastJsonConfig fastJsonConfig = new FastJsonConfig();
		// 自定义格式化输出
//		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat, SerializerFeature.WriteNullStringAsEmpty,
//				SerializerFeature.WriteNullNumberAsZero); // 会将null值写成空字符串
		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat, SerializerFeature.WriteNullNumberAsZero);

		FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
		// 中文乱码解决方案
        List&lt;MediaType&gt; mediaTypes = new ArrayList&lt;&gt;();
        mediaTypes.add(MediaType.APPLICATION_JSON_UTF8);//设定json格式且编码为UTF-8
        fastJsonHttpMessageConverter.setSupportedMediaTypes(mediaTypes);
		
        fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);
        
		return new HttpMessageConverters(fastJsonHttpMessageConverter);
	}
</code></pre>

<h2 id="5-5-启动前执行方法的几种方式">5.5 启动前执行方法的几种方式</h2>

<ol>
<li>使用@PostConstruct注解</li>
<li>实现<code>InitializingBean</code>接口</li>
<li>实现<code>BeanPostProcessor</code>接口</li>
</ol>

<p>以上几种初始化方法，执行顺序依次为 <code>@PostConstruct&lt;-InitializingBean&lt;-BeanPostProcessor</code></p>

<h1 id="6-quartz任务调度">6. Quartz任务调度</h1>

<h2 id="6-1-基本对象">6.1 基本对象</h2>

<ol>
<li><code>Scheduler:</code>调度器。所有的调度都是由它控制。</li>
<li><code>Trigger:</code> 定义触发的条件。</li>
<li><code>Job:</code> 包含真正的执行逻辑。</li>
<li><code>JobDetail :</code> 定义任务数据。</li>
</ol>

<p><code>job &amp; jobdetail：</code> JobDetail &amp; Job 方式，sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。  使用任务调度+事件的方式可以实现许多复杂的功能。</p>

<h1 id="7-redis-入门">7. Redis 入门</h1>

<h2 id="7-1-redis基本数据类型">7.1 redis基本数据类型</h2>

<table>
<thead>
<tr>
<th>数据类型</th>
<th>数据类型存储的值</th>
</tr>
</thead>

<tbody>
<tr>
<td>String</td>
<td>可以保持字符串、整数、浮点数</td>
</tr>

<tr>
<td>List</td>
<td>链表，链表的每个节点可以保存字符串</td>
</tr>

<tr>
<td>Set</td>
<td>无序集合，集合里的每个元素都是字符串</td>
</tr>

<tr>
<td>Hash</td>
<td>类似java中的map，是一个键值对应的无序列表</td>
</tr>

<tr>
<td>Zset</td>
<td>有序集合，可以包含字符串、整数、浮点数、分值（score），元素的排序是依据分值的大小来决定的</td>
</tr>

<tr>
<td>HyperLogLog</td>
<td>它的作用是计算重复的值，以确定存储的数量</td>
</tr>
</tbody>
</table>

<h2 id="7-2-常用命令">7.2 常用命令</h2>

<h3 id="7-2-1-字符串">7.2.1 字符串</h3>

<table>
<thead>
<tr>
<th>redis命令</th>
<th>spring中操作命令</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>set key value</td>
<td>set(key, value)</td>
<td>设置键值对</td>
</tr>

<tr>
<td>get key</td>
<td>get(key)</td>
<td>根据key获取值</td>
</tr>

<tr>
<td>del key</td>
<td>delete(key)</td>
<td>通过key删除值</td>
</tr>

<tr>
<td>strlen key</td>
<td>size(key)</td>
<td>求key指向字符串的长度</td>
</tr>

<tr>
<td>getset key value</td>
<td>getAndSet(key, value)</td>
<td>修改原来key对应的值，并将旧值返回</td>
</tr>

<tr>
<td>getrange key start end</td>
<td>get(key, start, end)</td>
<td>获取子串</td>
</tr>

<tr>
<td>append key value</td>
<td>append(key, value)</td>
<td>将新字符串加入到原来key指向的字符串末</td>
</tr>

<tr>
<td>incr key</td>
<td>increment(key, 1)</td>
<td>原字段加1        （整数有效</td>
</tr>

<tr>
<td>incrby key increment</td>
<td>increment(key, value)</td>
<td>原字段加整数     （整数有效</td>
</tr>

<tr>
<td>decr key</td>
<td><code>查看备注</code></td>
<td>原字段减1     （整数有效</td>
</tr>

<tr>
<td>decr key increment</td>
<td><code>查看备注</code></td>
<td>原字段减去整数     （整数有效</td>
</tr>

<tr>
<td>incrbyfloat keyincrement</td>
<td>increment(key, value)</td>
<td>原字段加上浮点数     （整数或浮点数都<strong>有效</strong></td>
</tr>
</tbody>
</table>

<p><strong><code>注：</code></strong> spring已经对加法进行了封装，因此<code>increment（key, value）</code>方法不仅可以支持整数，还可以支持long/double等数据类型的加法操作，对于减法，参考如下代码段。</p>

<pre><code class="language-java">redisTemplate.getConnectionFactory().getConnection().decrBy(
	redisTemplate.getKeySerializer().serialize(key), value
);
</code></pre>

<p>值得注意的是对于以上代码的减法操作，被减数，即key上的原有值只能是整数不能是浮点数，否则可能会产生异常。</p>

<h3 id="7-2-2-哈希">7.2.2 哈希</h3>

<table>
<thead>
<tr>
<th>redis命令</th>
<th>spring命令</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>HMSet key field1 value1 [field2 value2 ]</td>
<td>putAll(key, map)</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>

<tr>
<td>HSet key field value</td>
<td>put(key, field, value)</td>
<td>将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>

<tr>
<td>HSetNx key field value</td>
<td>putIfAbsent(key, field, value)</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>

<tr>
<td>HVals key</td>
<td>values(key)</td>
<td>获取哈希表中所有值,返回list</td>
</tr>

<tr>
<td>HLen key</td>
<td></td>
<td>获取哈希表中字段的数量</td>
</tr>

<tr>
<td>HKeys key</td>
<td>keys(key)</td>
<td>获取所有哈希表中的字段</td>
</tr>

<tr>
<td>HIncrBy key field increment</td>
<td></td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>

<tr>
<td>HMGet key field1 [field2 ]</td>
<td>multiGet(key, keyList)</td>
<td>获取所有给定字段的值</td>
</tr>

<tr>
<td>HGetAll key</td>
<td>entries(key)</td>
<td>获取在哈希表中指定 key 的所有字段和值</td>
</tr>

<tr>
<td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></td>
<td></td>
<td>迭代哈希表中的键值对。</td>
</tr>

<tr>
<td>HDelkey field1 [field2]</td>
<td></td>
<td>删除一个或多个哈希表字段</td>
</tr>

<tr>
<td>HINCRBY key field increment</td>
<td></td>
<td>给hash表中某字段加上一个整数</td>
</tr>

<tr>
<td>HIncrByFloat key field increment</td>
<td></td>
<td>给hash表中某字段加上一个浮点数</td>
</tr>

<tr>
<td>Hexists key field</td>
<td>hasKey(key,field)</td>
<td>是否存在键值对</td>
</tr>
</tbody>
</table>

<h1 id="8-关于sql">8 关于SQL</h1>

<h2 id="8-1-常用sql">8.1 常用sql</h2>

<h3 id="8-1-1-根据时间条件删除目标">8.1.1 根据时间条件删除目标</h3>

<pre><code class="language-sql">-- 其中 `now()` 是当前时间， `createtime`是数据库中的一个字段，即创建该字段的时间
DELETE from table_info WHERE DATEDIFF(now(),createtime) &gt;7
</code></pre>

<h1 id="9-数据转换">9 数据转换</h1>

<h2 id="1-1-date转换">1.1 Date转换</h2>

<h3 id="1-1-1-eee-mmm-dd-hh-mm-ss-z-yyyy格式date转换">1.1.1 EEE MMM dd HH:mm:ss z yyyy格式Date转换</h3>

<pre><code class="language-java">SimpleDateFormat sdf = new SimpleDateFormat(&quot;EEE MMM dd HH:mm:ss z yyyy&quot;, Locale.US);
Date date = sdf.parse(&quot;Sat Oct 12 07:38:06 CST 2019&quot;);
</code></pre>

    </div>
    
  </div>
</article>

  
    <article class="post bg-white">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/post/development/dorcker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">docker的简单使用</a>
    </h1>
    
    <div class="post-meta">
      <time datetime="2019-09-03" class="post-time">
        2019-09-03
      </time>
      <div class="post-category">
          <a href="https://hisaige.github.io/categories/development/"> Development </a>
          
        </div>
      <span class="more-meta"> 1434 words </span>
      <span class="more-meta"> 3 min read </span>
      
      
      
    </div>
  </header>
  
  <div class="post-content">
    
    <div class="post-summary">
      

<h1>docker的简单使用</h1>

<h2 id="1-安装">1. 安装</h2>

<p>1.如果装了新版本，先卸载旧版</p>

<pre><code class="language-shell">sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
</code></pre>

<ol>
<li><p>安装所需的包</p>

<pre><code class="language-shell">sudo yum install -y yum-utils \
device-mapper-persistent-data \
lvm2
</code></pre></li>

<li><p>设置<strong>稳定</strong>存储库</p>

<pre><code class="language-shell"># docker切换阿里源（生产环境慎重）
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

# 使用官方推荐的存储库，由于是国外网站，卡慢
sudo yum-config-manager \
--add-repo \
https://download.docker.com/linux/centos/docker-ce.repo
</code></pre></li>

<li><p>安装最新版</p>

<pre><code class="language-shell">sudo yum install docker-ce docker-ce-cli containerd.io

# 安装完毕后，可以使用以下命令查看docker版本
docker version
</code></pre></li>

<li><p>配置阿里云镜像加速和本地工作目录</p></li>
</ol>

<p>​   ①添加并配置 /etc/docker/daemon.json 文件。</p>

<p>​   ②修改配置文件内容为, <code>/usr/local/docker</code> 是工作目录</p>

<pre><code class="language-shell">{
&quot;data-root&quot;: &quot;/usr/local/docker&quot;,
&quot;registry-mirrors&quot;: [
&quot;https://kfwkfulq.mirror.aliyuncs.com&quot;,
&quot;https://2lqq34jg.mirror.aliyuncs.com&quot;,
&quot;https://aa25jngu.mirror.aliyuncs.com&quot;,
&quot;https://registry.docker-cn.com&quot;
]
}
</code></pre>

<h2 id="2-使用docker">2. 使用docker</h2>

<ol>
<li><p>万物皆起于 <code>hello-world</code></p>

<pre><code class="language-shell"># 1.拉取hello-world镜像
docker pull hello-world

# 2.运行hello-world
docker run hello-world

# 3.运行时如果出现以下文字，说明hello-world运行成功
[root@localhost docker]# docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
(amd64)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
$ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
https://hub.docker.com/

For more examples and ideas, visit:
https://docs.docker.com/get-started/
#运行成功
</code></pre></li>

<li><p>镜像常用命令</p></li>
</ol>

<p><code>-a</code> ：列出本地所有的镜像（含中间映像层）</p>

<p><code>-q</code> :  只显示镜像ID</p>

<p><code>--digests</code> : 显示镜像的摘要信息</p>

<p><code>--no-trunc</code> : 显示完整的镜像信息</p>

<pre><code class="language-shell"># 1.帮助信息
docker --help

# 2.显示所有镜像信息
docker images

# 3.去docker仓库查找镜像
docker search xxx镜像名
# 显示前两条
docker search tomcat -limit 2
#显示stars超过2000的
docker search tomcat --filter=stars=2000


# 4.删除镜像, 以下 镜像id 可以换成 镜像名 -f强制删除
docker rmi -f 镜像ID
#删除多个
docker rmi -f 镜像id1 镜像id2 镜像id3 ...
#删除全部
docker rmi -f $(docker images -q)

# 5. 删除容器 -f强制删除 -a全部容器 -q 返回容器id
docker rm 容器ID
# 删除全部容器
docker rm $(docker ps -aq)


</code></pre>

<ol>
<li><p>容器常用命令</p>

<pre><code class="language-shell"># 1.新建启动容器
docker run 容器名/容器id
#启动容器
docker start 容器id或容器名
## --name=&quot;容器新名字&quot; 为容器指定一个名称
## -d:后台运行容器，并返回容器id
## -i:以交互模式运行容器，通常与 -t 联合使用
## -t：为容器重新分配一个输入终端
## (以 -it 方式启动时会进入伪终端，推出伪终端并停止使用 exit 指令，退出伪终端不关闭容器快捷键ctrl+p+q)
## -P：随机端口映射
## -p:指定端口映射
		#通常有以下四种方式做映射
		#1. ip:port:containerPort
		#2. ip:containerPort
		#3. hostPort:containerPort
		#4.containerPort
		
# 2. 停止容器
docker stop 容器名或容器id
#强制停止
docker kill 容器id或容器名

# 3.删除容器 -f表示强制删除 -a表示关闭的容器 -q表示存活的容器
docker rm -f $(docker ps -a -q)
#或
docker ps -a -q | xargs docker rm

# 4.退出容器/进入容器
	#方式1 容器停止退出
	exit
	#方式2 容器不停止退出
	ctrl + p + q
#进入容器
	#方式1 进入终端
	docker attach 容器ID
	#方式2 不进入终端 直接执行容器的功能指令
	docker exec -t 镜像id 容器指令

# 5.查看容器日志
docker logs
# -t 加入时间戳
# -f 跟随最新的日志打印
# 	--tail 数字 显示最后多少条

# 6.从容器内拷贝文件到主机
docker cp 容器id:容器内路径 主机路径
</code></pre></li>

<li><p>DockerFile保留字指令</p></li>
</ol>

<table>
<thead>
<tr>
<th>build</th>
<th>both</th>
<th>run</th>
</tr>
</thead>

<tbody>
<tr>
<td>FROM</td>
<td>WORKDIR</td>
<td>CMD</td>
</tr>

<tr>
<td>MAINTAINER</td>
<td>USER</td>
<td>ENV</td>
</tr>

<tr>
<td>COPY</td>
<td></td>
<td>EXPOSE</td>
</tr>

<tr>
<td>ADD</td>
<td></td>
<td>VOLUME</td>
</tr>

<tr>
<td>RUN</td>
<td></td>
<td>ENTRYPOINT</td>
</tr>

<tr>
<td>ONBUILD</td>
<td></td>
<td></td>
</tr>

<tr>
<td>.dockerignore</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<ol>
<li>制作自定义linux镜像</li>
</ol>

<h2 id="n-linux随笔">n. linux随笔</h2>

<ol>
<li><p>vim/vi编辑文件时退出方式</p>

<pre><code class="language-shell">按ESC键 跳到命令模式，然后：

:w - 保存文件，不退出 vim
:w file -将修改另外保存到 file 中，不退出 vim
:w! -强制保存，不退出 vim
:wq -保存文件，退出 vim
:wq! -强制保存文件，退出 vim
:q -不保存文件，退出 vim
:q! -不保存文件，强制退出 vim
:e! -放弃所有修改，从上次保存文件开始再编辑
</code></pre></li>

<li><p>常用系统指令</p>

<pre><code class="language-shell">重载系统服务(修改配置文件后需要做的事儿)：systemctl daemon-reload

设置开机启动：systemctl enable *.service

启动服务：systemctl start *.service

停止服务：systemctl stop *.service

重启服务：systemctl reload *.service
</code></pre></li>
</ol>

<p>​</p>

    </div>
    
  </div>
</article>

  
    <article class="post bg-white">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/post/tool/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8/">idea快捷键使用</a>
    </h1>
    
    <div class="post-meta">
      <time datetime="2019-09-03" class="post-time">
        2019-09-03
      </time>
      <div class="post-category">
          <a href="https://hisaige.github.io/categories/tool/"> Tool </a>
          
        </div>
      <span class="more-meta"> 462 words </span>
      <span class="more-meta"> 1 min read </span>
      
      
      
    </div>
  </header>
  
  <div class="post-content">
    
    <div class="post-summary">
      

<p><center><h1>
    idea快捷键使用
</h1></center></p>

<h2 id="1-快捷-键">1. 快捷<strong>键</strong></h2>

<ol>
<li><strong>ctrl + n  == 搜索类、方法、属性</strong></li>
<li><strong>ctrl + shift + n == 搜索文件</strong></li>
<li>**ctrl + alt +n == 代码提示  **</li>
<li><strong>/  ctrl + alt + 空格 = 代码提示</strong></li>
<li><strong>alt + f7 == 查询在某处使用</strong></li>
<li><strong>ctrl + q == 查看代码提示及内容</strong></li>
<li><strong>ctrl + b  == 查看类的声明 ==ctrl+左键</strong></li>
<li><strong>ctrl + f12  == 查看文件列表（类的方法列表）</strong></li>
<li><strong>ctrl + alt + ⬆/⬇ = 查看 父类/子类</strong></li>
<li><strong>ctrl + shift + ⬆/⬇ = 上移/下移一行代码</strong></li>
<li><strong>连续两次shift  == 查找文件</strong><br /></li>
<li><strong>连安两下 shift 查找文件</strong></li>
<li><strong>CtrL +shift +r 全局搜索</strong></li>
<li><strong>ctrl +r 搜索替换当前页的单词</strong></li>
<li><strong>查看类继承关系图：Ctrl+Alt+U</strong></li>
<li><strong>查看定义的变量在哪里被调用：Ctrl+Alt+F7</strong></li>
<li><strong>查看Java方法调用树(被调/主调)：Ctrl+Alt+H</strong></li>
<li>**在codeStyle_java_import设置中，可以设置import多少个类自动变成import ***</li>
<li><strong>ctrl +alt +v 自动生成返回值</strong></li>
<li><strong>ctrl + alt +t 生成环绕代码块 surround with</strong></li>
<li><strong>ctl + alt + &lt;-  或 -&gt;   上一步或下一步</strong></li>
<li><strong>ctrl + alt + m  抽取代码为方法</strong></li>
<li><strong>ctrl + e 打开最近文件</strong></li>
<li><strong>ctrl + h 查看类的继承关系</strong></li>
<li><strong>ctr + shift + u 大小写转化</strong></li>
<li><strong>shift + enter 向下插入空行</strong></li>
<li><strong>ctrl + alt + enter 向上插入空行</strong></li>
</ol>

<h2 id="2-使用技巧">2.使用技巧</h2>

<p>debug篇</p>

<ol>
<li>右键断点可以设置进入断点条件</li>
<li><strong>ctrl + u</strong> 进入查看debug时表达式的值</li>
</ol>

    </div>
    
  </div>
</article>

  
</section>






  
  
  

  
  

  
  

  
  

  
  
  <nav class="pagination">
    <ul>
      
      <li  class="active" >
        <a href="/">1</a>
      </li>
      
      <li >
        <a href="/page/2/">2</a>
      </li>
      
    </ul>
  </nav>

  
  





        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:hisaige@163.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>


<a href="https://hisaige.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    2019
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        hisaige
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>



  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>



  <link rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css"
    integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG"
    crossorigin="anonymous">

  
  <script defer
    src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js"
    integrity="sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1"
    crossorigin="anonymous"></script>

  
  <script defer
    src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js"
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
    crossorigin="anonymous" onload="renderMathInElement(document.body);">
  </script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        
      });
    });
  </script>






  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  














  <script src="/js/head.js"></script>


</body>
</html>
