<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>目光呆滞的5741号代码搬运工</title>
    <link>https://hisaige.github.io/</link>
    <description>Recent content on 目光呆滞的5741号代码搬运工</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 15 Nov 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://hisaige.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>hisaige~啊呜~嗷哩个嗷@#￥%</title>
      <link>https://hisaige.github.io/post/docs/jane-theme-preview.zh-cn/</link>
      <pubDate>Sun, 01 Sep 2019 16:01:23 +0800</pubDate>
      
      <guid>https://hisaige.github.io/post/docs/jane-theme-preview.zh-cn/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;../../../imgs/jfjh.jpg&#34; alt=&#34;jfjh&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>About</title>
      <link>https://hisaige.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://hisaige.github.io/about/</guid>
      
        <description>&lt;p&gt;&lt;center&gt;目光呆滞的我，差点又迷路了&amp;hellip;&amp;hellip;&lt;/center&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>YAPI部署指南</title>
      <link>https://hisaige.github.io/post/docs/yapi%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hisaige.github.io/post/docs/yapi%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</guid>
      
        <description>

&lt;h1 align=&#34;center&#34;&gt;
    windows下node+mongodb+yapi安装教程
&lt;/h1&gt;

&lt;h1 id=&#34;1-安装node&#34;&gt;1. 安装node&lt;/h1&gt;

&lt;h2 id=&#34;1-1-登陆-node官网-https-nodejs-org-en-download-nodejs-下载windows解压版压缩包&#34;&gt;1.1 登陆&lt;a href=&#34;https://nodejs.org/en/download//&#34; title=&#34;nodeJs&#34;&gt;node官网&lt;/a&gt;下载windows解压版压缩包&lt;/h2&gt;

&lt;h2 id=&#34;1-2-将node解压后的目录配置到环境变量&#34;&gt;1.2 将node解压后的目录配置到环境变量&lt;/h2&gt;

&lt;p&gt;​   &lt;img src=&#34;../../../imgs/node环境变量.bmp&#34; alt=&#34;node环境变量&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-3-查看安装版本&#34;&gt;1.3 查看安装版本&lt;/h2&gt;

&lt;p&gt;​   &lt;img src=&#34;../../../imgs/node查看安装版本.bmp&#34; alt=&#34;node查看安装版本&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-4-配置node&#34;&gt;1.4 配置node&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装目录下新建两个文件夹node-cache 和node-global. 注意安装路径不要有空格&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行如下命令配置,即配置完毕&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;npm config set cache &amp;quot;E:\nodeInstall\node-v10.15.3-win-x64\node-cache&amp;quot;
npm config set prefix &amp;quot;E:\nodeInstall\node-v10.15.3-win-x64\node-global&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-5-安装pm2-pm2是运行node程序的强大插件&#34;&gt;1.5 安装PM2，PM2是运行node程序的强大插件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;npm install pm2@latest -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完后配置环境变量，将node-global目录配置到path中即可。&lt;/p&gt;

&lt;h2 id=&#34;1-6-pm2启动&#34;&gt;1.6 PM2启动&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//PM2启动yapi指令：
pm2 start server/app.js --watch
//PM2关闭yapi指令
pm2 stop server/app.js --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--watch&lt;/code&gt; 方式启动yapi，永久守护这个yapi进程，避免服务不稳定网站挂掉。&lt;/p&gt;

&lt;h1 id=&#34;2-安装mongodb&#34;&gt;2. 安装mongoDB&lt;/h1&gt;

&lt;h2 id=&#34;2-1-到-mongodb官网-https-www-mongodb-com-download-center-community-mongodb官网-下载mongodb压缩版安装包&#34;&gt;2.1 到&lt;a href=&#34;https://www.mongodb.com/download-center/community&#34; title=&#34;mongoDB官网&#34;&gt;mongoDB官网&lt;/a&gt; 下载mongoDB压缩版安装包&lt;/h2&gt;

&lt;h2 id=&#34;2-2-配置mongodb环境变量&#34;&gt;2.2 配置mongoDB环境变量&lt;/h2&gt;

&lt;p&gt;​   &lt;img src=&#34;../../../imgs/mongoDB配置环境变量.bmp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-3-mongodb配置&#34;&gt;2.3 mongoDB配置,&lt;/h2&gt;

&lt;p&gt;在bin目录下新增mongoDB配置文件&lt;code&gt;mongo.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;dbpath=D:\Program Files\mongodb\mongodb4.0.6\MongoDBData  #数据库路径  

logpath=D:\Program Files\mongodb\mongodb4.0.6\mongo.log #日志输出文件路径

logappend=true #错误日志采用追加模式                                                

journal=true #启用日志文件，默认启用  

quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false  

port=27017 #端口号 默认为2701
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行CMD, 输入&lt;code&gt;mongod --config &amp;quot;D:\Program Files\mongodb\mongodb4.0.6\bin\mongo.conf&amp;quot; --install --serviceName &amp;quot;MongoDB&amp;quot;&lt;/code&gt;将mongoDB安装到服务，启动服务，在浏览器输入localhost:27017如果出现以下信息即表示安装成功。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;It looks like you are trying to access MongoDB over HTTP on the native driver port.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-4-配置mongodb数据库用户&#34;&gt;2.4 配置mongoDB数据库用户&lt;/h2&gt;

&lt;p&gt;打开命令行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1. #启动MONGDB服务
# 2. 运行命令行
C:\Users\chenyj&amp;gt; mongo
 use admin   #切换到admin数据库
switched to db admin
#创建dba用户
db.createUser(
...    {
...      user: &amp;quot;root&amp;quot;,
...      pwd: &amp;quot;infinova1&amp;quot;,
...      roles: [ { role: &amp;quot;userAdminAnyDatabase&amp;quot;, db: &amp;quot;admin&amp;quot; } ]
...    }
...  )
#创建yapi数据库
use yapi
switched to db yapi
给yapi数据库添加test1用户,权限为读写
 db.createUser(
...     {
...       user: &amp;quot;yapi&amp;quot;,
...       pwd: &amp;quot;infinova&amp;quot;,
...       roles: [
...          { role: &amp;quot;readWrite&amp;quot;, db: &amp;quot;yapi&amp;quot; }  
...       ]
...     }
... )

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-安装yapi&#34;&gt;3. 安装yapi&lt;/h1&gt;

&lt;h2 id=&#34;3-1下载yapi&#34;&gt;3.1下载yapi&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir yapi
cd yapi
git clone https://github.com/YMFE/yapi.git vendors //或者下载 zip 包解压到 vendors 目录（clone 整个仓库大概 140+ M，可以通过 `git clone --depth=1 https://github.com/YMFE/yapi.git vendors` 命令减少，大概 10+ M）
cp vendors/config_example.json ./config.json //复制完成后请修改相关配置
cd vendors
npm install --production --registry https://registry.npm.taobao.org
npm run install-server //安装程序会初始化数据库索引和管理员账号，管理员账号名可在 config.json 配置
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-2-配置yapi&#34;&gt;3.2 配置yapi&lt;/h2&gt;

&lt;p&gt;打开yapi目录，新建 config.json文件如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;port&amp;quot;: &amp;quot;*****&amp;quot;,
  &amp;quot;adminAccount&amp;quot;: &amp;quot;********&amp;quot;,
  &amp;quot;db&amp;quot;: {...},
  &amp;quot;mail&amp;quot;: {
    &amp;quot;enable&amp;quot;: true,
    &amp;quot;host&amp;quot;: &amp;quot;smtp.*.com&amp;quot;,    //邮箱服务器
    &amp;quot;port&amp;quot;: 465,               //端口
    &amp;quot;from&amp;quot;: &amp;quot;***@szinfinova.com&amp;quot;,     //发送人邮箱
    &amp;quot;auth&amp;quot;: {
        &amp;quot;user&amp;quot;: &amp;quot;***@szinfinova.com&amp;quot;, //邮箱服务器账号
        &amp;quot;pass&amp;quot;: &amp;quot;*****&amp;quot;        //邮箱服务器密码
    }
  },
  &amp;quot;db&amp;quot;: {
	&amp;quot;servername&amp;quot;: &amp;quot;127.0.0.1&amp;quot;, //配置数据库
	&amp;quot;DATABASE&amp;quot;: &amp;quot;yapi&amp;quot;, //数据库名
	&amp;quot;port&amp;quot;: 27017, //端口
	&amp;quot;user&amp;quot;: &amp;quot;yapi&amp;quot;, //用户名
	&amp;quot;pass&amp;quot;: &amp;quot;infinova&amp;quot;, //密码
	&amp;quot;authSource&amp;quot;: &amp;quot;&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-3-启动yapi&#34;&gt;3.3 启动yapi&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;vendors&lt;/code&gt; 目录下新建&lt;code&gt;startup.bat&lt;/code&gt;文件，在里面添加内容如下,在启动mongoDB数据库服务后，双击&lt;code&gt;startup.bat&lt;/code&gt; 即可启动yapi项目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;node server/app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-3-pm2启动&#34;&gt;3.3 PM2启动&lt;/h2&gt;

&lt;h3 id=&#34;3-3-1-安装pm2&#34;&gt;3.3.1 安装pm2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-node&#34;&gt;npm install -g pm2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-3-2-pm2配置环境变量&#34;&gt;3.3.2  pm2配置环境变量&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;../../../imgs/pm2环境变量.bmp&#34; alt=&#34;PM2环境变量&#34; /&gt; &lt;img src=&#34;../../../imgs/pm2path.bmp&#34; alt=&#34;pm2PATH&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-3-3-查看pm2版本&#34;&gt;3.3.3 查看pm2版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-node&#34;&gt;## 打开CMD命令行 输入
pm2 -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   &lt;img src=&#34;../../../imgs/查看pm2版本.bmp&#34; alt=&#34;查看pm2版本&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-3-4-pm2启动yapi&#34;&gt;3.3.4 pm2启动yapi&lt;/h3&gt;

&lt;p&gt;查看1.6&lt;/p&gt;

&lt;h1 id=&#34;4-安装注意&#34;&gt;4. 安装注意&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;如果安装完node,npm命令无响应，可以删掉&lt;code&gt;C:\Users（用户）\你的用户名\.npmrc&lt;/code&gt; 这个文件。&lt;/li&gt;
&lt;li&gt;安装路径尽量不要有空格&lt;/li&gt;
&lt;li&gt;如果已经存在安装，要部署到其他电脑上，可以将安装好的node文件夹、mongoDB文件夹、yapi文件夹复制到目标环境，运行CMD, 输入&lt;code&gt;mongod --config &amp;quot;D:\Program Files\mongodb\mongodb4.0.6\bin\mongo.conf&amp;quot; --install --serviceName &amp;quot;MongoDB&amp;quot;&lt;/code&gt;将mongoDB安装mongoDB服务到新电脑环境（注意路径），配置好mongoDB和node的环境变量，双击startup即可启动yapi。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>SpringBoot 随笔</title>
      <link>https://hisaige.github.io/post/development/springboot%E9%9A%8F%E7%AC%94/</link>
      <pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hisaige.github.io/post/development/springboot%E9%9A%8F%E7%AC%94/</guid>
      
        <description>

&lt;p&gt;&lt;center&gt;&lt;font color=#0099ff size=7 &gt;SpringBoot 随笔&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-tips&#34;&gt;1. tips&lt;/h1&gt;

&lt;h2 id=&#34;1-1-jsr303数据校验&#34;&gt;1.1. JSR303数据校验&lt;/h2&gt;

&lt;h2 id=&#34;1-2-value-与-configurationproperties-注解&#34;&gt;1.2. @Value 与 @ConfigurationProperties 注解&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;@Value&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;@ConfigurationProperties&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;松散绑定&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;spEL&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;批量注解&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;JSR303数据校验&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;复杂类型（map、set等）&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;1-3-application-properties-application-yml-方式配置文件&#34;&gt;1.3. application.properties、application.yml 方式配置文件&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;application配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539496016269.png&#34; alt=&#34;perperties配置&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;yml配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;person:
	name: xujz
	age: 18
	flag: false
	birth: 2001/01/02
	maps: {k1: v1,k2:v2}
	lists: 
		- 111
		- aaa
	man:
		name: pengyg
		age: 30
	socket-address-holder:
       - port: 80
         url: 127.0.0.1
       - port: 90
         url: 10.82.13.241
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@ConfigurationProperties(prefix=&amp;quot;person&amp;quot;)
public class Person {

	private String name;
//	@Value(&amp;quot;${person.age}&amp;quot;) //从环境变量中取值,如要要用@value注解，则应把@ConfigurationProperties注释掉
	private Integer age; 
//	@Value(&amp;quot;true&amp;quot;) //字面量赋值
	private Boolean flag;
	private Date birth;
	private Map&amp;lt;String,Object&amp;gt; maps;
	private List&amp;lt;Object&amp;gt; lists;
	private Set&amp;lt;Object&amp;gt; sets;
	private Man man;
private List&amp;lt;SocketAddressHolder&amp;gt; socketAddressHolder;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-4-propertysource&#34;&gt;1.4. @PropertySource&lt;/h2&gt;

&lt;p&gt;当配置文件与springboot的系统配置没有太大关系时，可以将配置单独提取出来，避免application.properties文件过大导致后期不好维护&lt;/p&gt;

&lt;p&gt;如person.properties文件中配置如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;#person配置
person.name = pengz
person.age = 18
person.flag = false
person.birth = 1993/01/02
person.map.k1 = 1111
person.map.k2 = 2222
person.lists = 1, 2, 3, 4, 5, 6,7 ,8, 9
person.sets = cat, dog, pig
person.man.sex = male
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于的javaBean类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
@PropertySource(value=&amp;quot;classpath:person.properties&amp;quot;) //形式1，用@Value取值
/**
*形式2，可加载多个配置文件
*@PropertySource(value= {&amp;quot;classpath:person.properties&amp;quot;，&amp;quot;classpath:person2.properties&amp;quot;})//用@Value取值
*
*@ConfigurationProperties(prefix=&amp;quot;person&amp;quot;)//形式3.利用springboot特性从*.application取
*值，无需@Value取值
*/
public class Person2 {

	private String name;
//	@Value(&amp;quot;${person.age}&amp;quot;) //从环境变量中取值
	private Integer age; 
//	@Value(&amp;quot;true&amp;quot;) //字面量赋值
	private Boolean flag;
	private Date birth;
	private Map&amp;lt;String,Object&amp;gt; maps;
	private List&amp;lt;Object&amp;gt; lists;
	private Set&amp;lt;Object&amp;gt; sets;
	private Man man;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-5-配置文件中的占位符&#34;&gt;1.5. 配置文件中的占位符&lt;/h2&gt;

&lt;p&gt;random.int  、random.long  、random.value  、random.uuid&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;#person配置
person.name = pengz${random.int}
person.age = 18
person.flag = false
person.birth = 1993/01/02
person.map.k1 = 1111
person.map.k2 = 2222
person.lists = 1, 2, 3, 4, 5, 6,7 ,8, 9
person.sets = cat, dog, pig, ${person.name}
person.man.sex = male
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印person结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;Persion [name=pengz613728050, age=18, flag=false, birth=Sat Jan 02 00:00:00 CST 1993, maps=null, lists=[1, 2, 3, 4, 5, 6, 7, 8, 9], sets=[cat, dog, pig, pengz1619328081], man=Man [sex=male]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-6-配置profile&#34;&gt;1.6. 配置profile&lt;/h2&gt;

&lt;p&gt;默认情况下配置文件生效的是application.properties&lt;/p&gt;

&lt;p&gt;但是我们可以利用profile的特性选择使相应的配置文件生效&lt;/p&gt;

&lt;h3 id=&#34;1-6-1-对于-properties文件&#34;&gt;1.6.1 对于*.properties文件&lt;/h3&gt;

&lt;p&gt;如有三个配置文件,&lt;strong&gt;注意其中的命名规则&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​   &lt;img src=&#34;C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539503756153.png&#34; alt=&#34;配置文件&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它们的配置文件分别为&lt;/p&gt;

&lt;p&gt;application: server.port = 8081&lt;/p&gt;

&lt;p&gt;application-dev: server.port = 8082&lt;/p&gt;

&lt;p&gt;application-prod: server.port = 8083&lt;/p&gt;

&lt;p&gt;默认情况下 server.port = 8081生效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是，如果在application.properties中作如下配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;server.port = 8081
spring.profiles.active = prod
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则&lt;code&gt;server.port = 8083&lt;/code&gt;生效&lt;/p&gt;

&lt;h3 id=&#34;1-6-2-对于-yml文件&#34;&gt;1.6.2 对于*.yml文件&lt;/h3&gt;

&lt;p&gt;yml文件的配置方式如下，&lt;strong&gt;注意: 如果存在 &lt;code&gt;*.properties 文件&lt;/code&gt;， &lt;code&gt;*.properties 文件&lt;/code&gt;为准&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;server:
  port: 8081
spring:
  profiles:
    active: prod
---
server:
  port: 8082
spring:
  profiles: dev
  
---
server:
  port: 8083
spring:
  profiles: prod
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-6-3-在项目已经打包好后-如果有需要改变配置-可以用命令行的方式&#34;&gt;1.6.3 在项目已经打包好后，如果有需要改变配置，可以用命令行的方式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;java -jar 打包名 --springboot.profiles.active=dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-7-配置文件加载位置&#34;&gt;1.7. 配置文件加载位置&lt;/h2&gt;

&lt;p&gt;配置文件所在的位置存在优先级，高优先级的配置文件会覆盖低优先级的配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;file:./config &amp;lt;!-- 优先级1 ，项目根目录下的config文件夹--&amp;gt;
file:./
classpath:./config
classpath:./ &amp;lt;!-- 优先级4 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-8-常用注解&#34;&gt;1.8 常用注解&lt;/h2&gt;

&lt;h3 id=&#34;1-8-1-smartinitializingsingleton&#34;&gt;1.8.1 SmartInitializingSingleton&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;所有非lazy单例Bean实例化完成后，会调用该方法&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-8-2-常用校验注解&#34;&gt;1.8.2 常用校验注解&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NotEmpty 用在集合类上面
@NotBlank 用在String上面
@NotNull 用在八大基本类型及其包装类上

@Valid 基本校验注解
@Validated 功能稍微强大点，可以根据分组校验特定的字段， 如在添加数据时校验groups = { AddValidate.class}，更新数据时校验groups = { setValidate.class}的字段

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-8-3-dependson-依赖加载&#34;&gt;1.8.3 DependsOn 依赖加载&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class AppConfig {

    @Bean(initMethod = &amp;quot;initialize&amp;quot;)
    @DependsOn(&amp;quot;eventListener&amp;quot;)
    public EventPublisherBean eventPublisherBean () {
        return new EventPublisherBean();
    }

    @Bean(name = &amp;quot;eventListener&amp;quot;, initMethod = &amp;quot;initialize&amp;quot;)
    // @Lazy
    public EventListenerBean eventListenerBean () {
        return new EventListenerBean();
    }

    public static void main (String... strings) {
        new AnnotationConfigApplicationContext(AppConfig.class);
    }
}

//初始化顺序  eventListener --&amp;gt; eventPublisherBean
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-9常用类&#34;&gt;1.9常用类&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;HttpHeaderNames&lt;/code&gt; ：http请求头里包含的种类名字&lt;/p&gt;

&lt;h2 id=&#34;1-10-根据注解获取类名再实例化技巧&#34;&gt;1.10 根据注解获取类名再实例化技巧&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        if (context != null) {
            String[] endpointBeanNames = context.getBeanNamesForAnnotation(ServerEndpoint.class);
            for (String beanName : endpointBeanNames) {
                endpointClasses.add(context.getType(beanName));
            }
        }

        for (Class&amp;lt;?&amp;gt; endpointClass : endpointClasses) {
            registerEndpoint(endpointClass);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-11获取类路径的几种方式&#34;&gt;1.11获取类路径的几种方式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.File;
 import java.io.IOException;
 import java.net.URL;

 public class URLDemo {

     
     public static void main(String[] args) {
         URLDemo muDemo = new URLDemo();
         try {
             muDemo.showURL();
         } catch (IOException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
         }
     }

     public void showURL() throws IOException {

         // 第一种：获取类加载的根路径   D:\git\daotie\daotie\target\classes
         File f = new File(this.getClass().getResource(&amp;quot;/&amp;quot;).getPath());
         System.out.println(f);

         // 获取当前类的所在工程路径; 如果不加“/”  获取当前类的加载目录  D:\git\daotie\daotie\target\classes\my
         File f2 = new File(this.getClass().getResource(&amp;quot;&amp;quot;).getPath());
         System.out.println(f2);

         // 第二种：获取项目路径    D:\git\daotie\daotie
         File directory = new File(&amp;quot;&amp;quot;);// 参数为空
         String courseFile = directory.getCanonicalPath();
         System.out.println(courseFile);

 
         // 第三种：  file:/D:/git/daotie/daotie/target/classes/
         URL xmlpath = this.getClass().getClassLoader().getResource(&amp;quot;&amp;quot;);
         System.out.println(xmlpath);

 
         // 第四种： D:\git\daotie\daotie
         System.out.println(System.getProperty(&amp;quot;user.dir&amp;quot;));
         /*
          * 结果： C:\Documents and Settings\Administrator\workspace\projectName
          * 获取当前工程路径
          */

         // 第五种：  获取所有的类路径 包括jar包的路径
         System.out.println(System.getProperty(&amp;quot;java.class.path&amp;quot;));

     }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-12-利用接口控制系统初始化&#34;&gt;1.12 利用接口控制系统初始化&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义&lt;code&gt;SystemInit&lt;/code&gt;接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//接口实现方法里面推荐用try-catch,捕获异常，并打印日志
public interface SystemInit {
   
	void init() throws Exception;
   
	void unInit() throws Exception;
}
   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义&lt;code&gt;CacheInit&lt;/code&gt;接口继承&lt;code&gt;SystemInit&lt;/code&gt;接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface CacheInit&amp;lt;T&amp;gt; extends SystemInit {
   
	Map&amp;lt;String,T&amp;gt; getCache() throws Exception;
   	
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化系统资源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class TestInit {
   
	@Autowired
	private List&amp;lt;SystemInit&amp;gt; systemInit;
   	
	@PostConstruct
	public void init() {
   		
		systemInit.forEach(action -&amp;gt; {
			action.init();
		});
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-13-autowired注入时有多个bean可选择的情况&#34;&gt;1.13 @Autowired注入时有多个bean可选择的情况&lt;/h2&gt;

&lt;p&gt;​   如果配置文件和注解都声明了bean @Autowired注入 如果不用@Qualifier注解说明注入的是哪个bean 那么注入的bean的名字根据@Autowired注解注释的那个变量来判断 而不是默认首字母小写那个&lt;/p&gt;

&lt;p&gt;比如 有多个 Haha接口的实现类bean 一个bean的名字叫haha 另一个叫hahaImpl&lt;/p&gt;

&lt;p&gt;以下方式注入的是hahaImpl&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
private Haha hahaImpl;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;@Autowired
private Haha hahaImpl;&lt;/code&gt; 里面 变量不是hahaImpl 或者  haha  那么就会报错&lt;/p&gt;

&lt;h1 id=&#34;2-springboot加载beans的方式&#34;&gt;2. SpringBoot加载beans的方式&lt;/h1&gt;

&lt;h2 id=&#34;2-1-importresource&#34;&gt;2.1. @ImportResource&lt;/h2&gt;

&lt;p&gt;加载spring配置文件的一种方式，该注解用于容器启动类中。&lt;/p&gt;

&lt;p&gt;1.在启动类中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@RestController
@EnableAutoConfiguration
@ImportResource(locations = {&amp;quot;classpath:beans.xml&amp;quot;,&amp;quot;classpath:beans2.xml&amp;quot;}) //
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.beans.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
	xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt;

	&amp;lt;bean id=&amp;quot;helloService&amp;quot; class=&amp;quot;com.infinova.demo.service.HelloService&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.HelloService.class&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HelloService {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.测试类中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired
ApplicationContext context;

@Test
public void testBean() {
    System.out.println(context.containsBean(&amp;quot;helloService&amp;quot;)); //输出：true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-configuration&#34;&gt;2.2. @Configuration&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;bean配置类，将beans.xml与启动类中的@ImportResource去掉，其他不变,测试类输出结果仍未true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class SpringBootConfig {
	
	@Bean
	public HelloService helloService() {
		return new HelloService();
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;2-3-声明bean注解&#34;&gt;2.3. 声明bean注解&lt;/h2&gt;

&lt;p&gt;​   &lt;img src=&#34;C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539501048683.png&#34; alt=&#34;声明bean注解&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;额外话：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;​   &lt;img src=&#34;C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539501108661.png&#34; alt=&#34;声明注解&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-4-bean的作用域&#34;&gt;2.4. bean的作用域&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;C:UsersYF5050-013AppDataRoamingTyporatypora-user-images1539502143217.png&#34; alt=&#34;bean的作用域&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-5-import注解&#34;&gt;2.5. @Import注解&lt;/h2&gt;

&lt;p&gt;value值是一个数组，可以注入三种形式的类&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;普通javabean&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ImportSelector&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ImportBeanDefinitionRegistrar&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于&lt;code&gt;ImportSelector&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportSelector implements  ImportSelector{
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{&amp;quot;com.hisaige.bean.MySelector&amp;quot;};
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyImportBeanDefinitionRegistrar  implements ImportBeanDefinitionRegistrar{
    public void registerBeanDefinitions(
            AnnotationMetadata importingClassMetadata,
            BeanDefinitionRegistry registry) {
        RootBeanDefinition rootBeanDefinition = new 			RootBeanDefinition(Test.class);
        // 注册一个名字叫rectangle的bean
        registry.registerBeanDefinition(&amp;quot;test&amp;quot;, rootBeanDefinition);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置类中添加注解@import({MyImportSelector.class,MyImportBeanDefinitionRegistrar.class})可以将&lt;code&gt;MySelector.class&lt;/code&gt;、&lt;code&gt;Test.class&lt;/code&gt;放入spring容器中。&lt;/p&gt;

&lt;h2 id=&#34;2-6-importselector简单使用&#34;&gt;2.6 ImportSelector简单使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//自定义逻辑返回需要导入的组件
//使用 `@Import(MyImportSelect.class)`将其调用。
public class MyImportSelect implements ImportSelector {

	//返回值，就是到导入到容器中的组件全类名
	//AnnotationMetadata:当前标注@Import注解的类的所有注解信息
	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		//importingClassMetadata包含所有注解信息
		
		//不能反回null值
		return new String[] {ImportBean.class.getName()};
	}
	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-7-importaware简单使用&#34;&gt;2.7 @ImportAware简单使用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义配置类，继承ImportAware接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableConfigurationProperties(Person.class) //很重要，不然会报错说找不到Person这个bean
public class MyImportAwareConfig implements ImportAware {
   
	@Autowired
   private Person person;
   	
	@Override
	public void setImportMetadata(AnnotationMetadata importMetadata) {
	//importMetadata 可以获取注解信息	
		System.out.println(importMetadata.getAnnotationTypes());
		System.out.println(person.getName());
	}
   	
	/*
	 * @Bean public Test getTest() { Test test = new Test(); return test; }
	 */
   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义Person类,当然这个类和@ImportAware的使用并没有太多关系&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConfigurationProperties(prefix = &amp;quot;springboot.person&amp;quot;)
public class Person {
   
	private String name;;
	private Integer age;
	private String sex;
	...setter and getter...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义我们自己的注解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)
@Target(value = { java.lang.annotation.ElementType.TYPE })
@Documented
@Import({ MyImportAwareConfig.class })
@Configuration
public @interface EnableDemo {
   String param() default &amp;quot;&amp;quot;;
}
   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用我们自己的注解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@EnableDemo(param=&amp;quot;aa&amp;quot;)
public class Test {
   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置文件信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;springboot: 
 person:
   name: jz
   sex: male
   age: 20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行结果打印如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;{param=[aa]}
[spring.boot.aware.EnableDemo]
jz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;2-8-embeddedvalueresolveraware&#34;&gt;2.8 EmbeddedValueResolverAware&lt;/h2&gt;

&lt;p&gt;valueResolver可以解析环境变量中的字符串, 示例如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PropertySource(&amp;quot;classpath:/dbconfig.properties&amp;quot;)
@Configuration
public class MainConfigOfProfile implements EmbeddedValueResolverAware{
    @Override
	public void setEmbeddedValueResolver(StringValueResolver resolver) {
		// TODO Auto-generated method stub
		this.valueResolver = resolver;
		driverClass = valueResolver.resolveStringValue(&amp;quot;${db.driverClass}&amp;quot;);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-9-项目启动时排除某个bean或某个自动装配&#34;&gt;2.9 项目启动时排除某个bean或某个自动装配&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 在启动类的@EnableAutoConfiguration或@SpringBootApplication后添加(exclude = //{DataSourceAutoConfiguration.class})，排除此类的autoconfig。启动以后就可以正常运行。
//如：
@EnableAutoConfiguration(exclude = {SecurityAutoConfiguration.class })
//或
@SpringBootApplication(exclude = {SecurityAutoConfiguration.class })
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-自定义startter&#34;&gt;3. 自定义startter&lt;/h1&gt;

&lt;h2 id=&#34;3-1&#34;&gt;3.1&lt;/h2&gt;

&lt;h1 id=&#34;4-aop&#34;&gt;4.AOP&lt;/h1&gt;

&lt;h2 id=&#34;4-1-execution表达式&#34;&gt;4.1 execution表达式&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;.imgsexecution表达式.bmp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;execution：用于匹配方法执行的连接点；&lt;/p&gt;

&lt;p&gt;​         within：用于匹配指定类型内的方法执行；&lt;/p&gt;

&lt;p&gt;​         this：用于匹配当前AOP代理对象类型的执行方法；注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配；&lt;/p&gt;

&lt;p&gt;​         target：用于匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；&lt;/p&gt;

&lt;p&gt;​         args：用于匹配当前执行的方法传入的参数为指定类型的执行方法；&lt;/p&gt;

&lt;p&gt;​         @within：用于匹配所以持有指定注解类型内的方法；&lt;/p&gt;

&lt;p&gt;​         @target：用于匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解；&lt;/p&gt;

&lt;p&gt;​         @args：用于匹配当前执行的方法传入的参数持有指定注解的执行；&lt;/p&gt;

&lt;p&gt;​         @annotation：用于匹配当前执行方法持有指定注解的方法；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;execution()
表达式结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;execution(&amp;lt;修饰符&amp;gt;? &amp;lt;返回类型&amp;gt; &amp;lt;包名&amp;gt;?&amp;lt;方法名&amp;gt;(&amp;lt;参数&amp;gt;)异常?)
execution(
  modifier-pattern?
  returnType-pattern
  package-pattern?
  methodName-pattern(args-pattern)
  throwException-pattern?
)
execution(*[修饰符]? *[返回值] *[包路径]?*[方法名](..[参数])throw *[异常类]?)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修饰符匹配(modifier-pattern)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1.修饰符匹配(modifier-pattern)
   //匹配所有public修饰的方法
  @Pointcut(&amp;quot;execution(public * **(..))&amp;quot;)
  public void exTest1(){}
2.返回值匹配(returnType-pattern)
   //匹配所有String或者void返回值的方法
  @Pointcut(&amp;quot;execution(String||void **(..))&amp;quot;)
  public void exTest2(){}
3.包路径匹配(package-pattern)
  //com包下的所有类的方法
  @Pointcut(&amp;quot;execution(* com.*.*(..))&amp;quot;)
  public void exTest3(){}
  
  //如果不使用..匹配到了类级别的名字,需要类.方法名.............
  //com包下的所有子包的所有类的方法
  @Pointcut(&amp;quot;execution(* com..*(..))&amp;quot;)
  public void exTest4(){}
  
  //com包下的所有子包的ProductService类的方法
  @Pointcut(&amp;quot;execution(* com..ProductService.*(..))&amp;quot;)
  public void exTest5(){}
  
4.方法名匹配(methodName-pattern)
   //匹配所有test名字开头的方法
  @Pointcut(&amp;quot;execution(* test*(..))&amp;quot;)
  public void exTest6(){}
  
  //匹配所有包含test名字的方法
  @Pointcut(&amp;quot;execution(* *test*(..))&amp;quot;)
  public void exTest7(){}
5.参数匹配(args-pattern)
  //匹配所有参数列表的方法
  @Pointcut(&amp;quot;execution(* *(..))&amp;quot;)
  public void exTest8(){}
  
  //匹配无参数列表的方法
  @Pointcut(&amp;quot;execution(* *())&amp;quot;)
  public void exTest9(){}
6.异常匹配(throwsException-pattern)
  //匹配所有抛过异常的方法
  @Pointcut(&amp;quot;execution(* *()throws *)&amp;quot;)
  public void exTest10(){}
  
  //只匹配所有抛出空指针异常的方法
  @Pointcut(&amp;quot;execution(* *()throws NullPointerException)&amp;quot;)
  public void exTest11(){}
  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;匹配注解&#34;&gt;匹配注解&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1.@target()
//匹配所有使用了AspectAnnotation注解的类的所有方法(要求注解的RetentionPolicy的级别为RUNTIME)
  @Pointcut(&amp;quot;@target(com.tiglle.manage.AspectAnnotation)&amp;quot;)
  public void targetMatch(){}
  
2.@args()
//匹配所有使用了AspectAnnotation注解为参数的方法
  @Pointcut(&amp;quot;@args(com.tiglle.manage.AspectAnnotation)&amp;quot;)
  public void argsMatch(){}
3.@within
//匹配所有使用了AspectAnnotation注解的类的所有方法(要求注解的RetentionPolicy的级别为CLASS)
  @Pointcut(&amp;quot;@within(com.tiglle.manage.AspectAnnotation)&amp;quot;)
  public void withinMatch(){}
4.@annotation()
  //方法注解匹配,匹配所有带AspectAnnotation注解的方法
  @Pointcut(&amp;quot;@annotation(com.tiglle.manage.annotation.AspectAnnotation)&amp;quot;)
  public void test(){
  }
  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;匹配包或者类型&#34;&gt;匹配包或者类型&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1.within() 如果传的是全类名(包名.类名):匹配此类下所有的方法
  //匹配TestService类中的所有方法
   @Pointcut(&amp;quot;within(com.tiglle.service.TestService)&amp;quot;)
   public voud test(){}
2.within() 如果传的时包名:匹配此包下所有类的方法
//匹配com/tiglle/包下所有包和子包中的类中的所有方法
	@Pointcut(&amp;quot;within(com.tiglle..*)&amp;quot;)
	public voud test(){}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;匹配对象&#34;&gt;匹配对象&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1. this()
  //匹配代理对象和普通对象及其所有子类的方法
  @Pointcut(&amp;quot;this(com.tiglle.manage.service.ProductService)&amp;quot;)
  public void thisMatch(){
  }
2.bean()
  //根据spring容器的bean的名称(id)匹配,(不匹配子类)
  @Pointcut(&amp;quot;bean(productService)&amp;quot;)
  public void beanMatch(){
  }
3.target()
  //匹配目标对象和普通对象及其所有子类的方法
  @Pointcut(&amp;quot;target(com.tiglle.manage.service.ProductService)&amp;quot;)
  public void targetMatch(){
  }
  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;匹配参数&#34;&gt;匹配参数&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1.args()匹配spring容器所有此参数类型和列表的方法(String,Long)
  //匹配spring容器所有此参数类型和列表的方法(String,Long)
  @Pointcut(&amp;quot;args(String,Long)&amp;quot;)
  public void argsMatch(){}
2.args()匹配spring容器所有此参数类型和列表的方法(第一个为Long,后面随意)
  //匹配spring容器所有此参数类型和列表的方法(第一个为Long,后面随意)
  @Pointcut(&amp;quot;args(Long,..)&amp;quot;)
  public void argsMatch2(){}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用连接符连接切面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Pointcut(&amp;quot;@annotation(com.hisaige.annotation.Enhance) || @within(com.hisaige.annotation.Enhance))&amp;quot;)
	public void pointcut() {
  
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;5-spring常用工具&#34;&gt;5. spring常用工具&lt;/h1&gt;

&lt;h2 id=&#34;5-1-获取父类-接口泛型&#34;&gt;5.1 获取父类/接口泛型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义父类或父接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface TypeResolverService&amp;lt;T&amp;gt; {
   
	T getStr();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义子类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TypeResolverServiceImpl implements TypeResolverService&amp;lt;String&amp;gt; {
   
	@Override
	public String getStr() {
		// TODO Auto-generated method stub
		return null;
	}
}
   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取泛型信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class GenericTypeResolverTest {
	public static void main(String[] args) {
		SpringApplication.run(GenericTypeResolverTest.class, args);
		ResolvableType resolvableType = ResolvableType.forClass(TypeResolverServiceImpl.class).as(TypeResolverService.class);
		boolean flag = resolvableType.hasGenerics();//判断是否有泛型
		if(flag) {
			System.out.println(&amp;quot;T -&amp;gt;&amp;quot; + resolvableType.getGenerics()[0]); //获取第一个泛型信息
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;T -&amp;gt;java.lang.String
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;5-2-resttemplate-工具类&#34;&gt;5.2 RestTemplate 工具类&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解决url中文乱码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean(name = &amp;quot;outerRestTemplate&amp;quot;)
   public RestTemplate getRestTemplate(){
       RestTemplate restTemplate = new RestTemplate();
       //解决中文乱码
       restTemplate.getMessageConverters().set(1, new 	 	    		                   StringHttpMessageConverter(StandardCharsets.UTF_8));
       return restTemplate;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ObjectProvider&lt;/code&gt;隐式注入，如以下代码段，messageConverters，restTemplateCustomizers 有则注入，没有就不。spring4.3后才有&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public RestTemplateConfiguration(
				ObjectProvider&amp;lt;HttpMessageConverters&amp;gt; messageConverters,
				ObjectProvider&amp;lt;List&amp;lt;RestTemplateCustomizer&amp;gt;&amp;gt; restTemplateCustomizers) {
			this.messageConverters = messageConverters;
			this.restTemplateCustomizers = restTemplateCustomizers;
		}
   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;5-3-resttemplate踩坑记录&#34;&gt;5.3 RestTemplate踩坑记录&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;RestTemplate配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//连接属性
@ConfigurationProperties(prefix = &amp;quot;http.config&amp;quot;)
public class HttpClientProperty {
   
	  private int maxTotalConnect; //连接池的最大连接数
	  private int maxConnectPerRoute; //单个主机的最大连接数
	  private int connectTimeout; //连接超时默认2s
	  private int readTimeout; //读取超时默认30s
   ...setter and getter...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置RestTemplate,将RestTemplate加入bean容器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ConditionalOnClass(value = { RestTemplate.class, HttpClient.class })
//如果没有@EnableConfigurationProperties，就必须将HttpClientProperty加入bean容器，如添加@Component注解
@EnableConfigurationProperties(HttpClientProperty.class) 
public class RestTemplateConfiguration {
   
	@Autowired
	private HttpClientProperty httpClientProperty;
   
	// 创建HTTP客户端工厂   @Deprecated 分模块代替
	/*
	 * private ClientHttpRequestFactory createFactory() { if
	 * (httpConfObj.getMaxTotalConnect() &amp;lt;= 0) { SimpleClientHttpRequestFactory
	 * factory = new SimpleClientHttpRequestFactory();
	 * factory.setConnectTimeout(httpConfObj.getConnectTimeout());
	 * factory.setReadTimeout(httpConfObj.getReadTimeout()); return factory; }
	 * HttpClient httpClient =
	 * HttpClientBuilder.create().setMaxConnTotal(httpConfObj.getMaxTotalConnect())
	 * .setMaxConnPerRoute(httpConfObj.getMaxConnectPerRoute()).build();
	 * HttpComponentsClientHttpRequestFactory factory = new
	 * HttpComponentsClientHttpRequestFactory(httpClient);
	 * factory.setConnectTimeout(httpConfObj.getConnectTimeout());
	 * factory.setReadTimeout(httpConfObj.getReadTimeout()); return factory; }
	 */
   
	// 初始化RestTemplate,并加入spring的Bean工厂，由spring统一管理
	@Bean
	@ConditionalOnMissingBean(RestTemplate.class)
	public RestTemplate getRestTemplate(RestTemplateBuilder builder) {
		RestTemplate restTemplate = new RestTemplate(clientHttpRequestFactory());
   
		List&amp;lt;HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converterList = restTemplate.getMessageConverters();
   
		// 重新设置StringHttpMessageConverter字符集为UTF-8，解决中文乱码问题
		HttpMessageConverter&amp;lt;?&amp;gt; converterTarget = null;
		for (HttpMessageConverter&amp;lt;?&amp;gt; item : converterList) {
			if (StringHttpMessageConverter.class == item.getClass()) {
				converterTarget = item;
				break;
			}
		}
		if (null != converterTarget) {
			converterList.remove(converterTarget);
		}
		converterList.add(1, new StringHttpMessageConverter(StandardCharsets.UTF_8));
   
		//
		/**
		 * 加入FastJson转换器 根据使用情况进行操作，此段注释，默认使用jackson
		 * spring的json转换器默认使用的是Jackson，json字符串和对应的Entity如果有字段对不上就会报错，这点很重要(踩过大坑》。。。)
		 * 如果使用的实体信息比较标准，可以使用jackson，个人使用FastJsonHttpMessageConverter，可以将请求结果直接转成JSONObject
		 */
		converterList.add(new FastJsonHttpMessageConverter());
		return restTemplate;
	}
   
	/**
	 * 配置Http请求转换器
	 * @return
	 */
	@Bean
	@ConditionalOnMissingBean
	public HttpMessageConverters fastjsonConverter() {
		FastJsonConfig fastJsonConfig = new FastJsonConfig();
		// 自定义格式化输出
//		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat, SerializerFeature.WriteNullStringAsEmpty,
//				SerializerFeature.WriteNullNumberAsZero); // 会将null值写成空字符串
		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat, SerializerFeature.WriteNullNumberAsZero);
   
		FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
		// 中文乱码解决方案
       List&amp;lt;MediaType&amp;gt; mediaTypes = new ArrayList&amp;lt;&amp;gt;();
       mediaTypes.add(MediaType.APPLICATION_JSON_UTF8);//设定json格式且编码为UTF-8
       fastJsonHttpMessageConverter.setSupportedMediaTypes(mediaTypes);
   		
       fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);
           
		return new HttpMessageConverters(fastJsonHttpMessageConverter);
	}
   
	@Bean
	@ConditionalOnMissingBean
	public HttpClientConnectionManager poolingConnectionManager() {
		PoolingHttpClientConnectionManager poolingConnectionManager = new PoolingHttpClientConnectionManager();
		poolingConnectionManager.setMaxTotal(1000); // 连接池最大连接数
		poolingConnectionManager.setDefaultMaxPerRoute(100); // 每个主机的并发
		return poolingConnectionManager;
	}
   
	@Bean
	@ConditionalOnMissingBean
	public HttpClientBuilder httpClientBuilder() {
		HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();
		// 设置HTTP连接管理器
		httpClientBuilder.setConnectionManager(poolingConnectionManager());
		return httpClientBuilder;
	}
   
	@Bean
	@ConditionalOnMissingBean
	public ClientHttpRequestFactory clientHttpRequestFactory() {
		if (httpClientProperty.getMaxTotalConnect() &amp;lt;= 0) {
			SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
			factory.setConnectTimeout(httpClientProperty.getConnectTimeout());
			factory.setReadTimeout(httpClientProperty.getReadTimeout());
			return factory;
		} else {
			HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory();
			clientHttpRequestFactory.setHttpClient(httpClientBuilder().build());
			clientHttpRequestFactory.setConnectTimeout(httpClientProperty.getConnectTimeout()); // 连接超时，毫秒
			clientHttpRequestFactory.setReadTimeout(httpClientProperty.getReadTimeout()); // 读写超时，毫秒
			return clientHttpRequestFactory;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用RestTemplate,共包含两个请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service
public class RestTemplateService {
   
	@Autowired
	private RestTemplate restTemplate;
   	
	public String testRestTemplate() throws UnsupportedEncodingException {
   		
		HttpHeaders headers = new HttpHeaders();
       MediaType type = MediaType.parseMediaType(&amp;quot;application/json; charset=UTF-8&amp;quot;);
       headers.setContentType(type);
       headers.add(&amp;quot;Accept&amp;quot;, &amp;quot;*/*&amp;quot;);
       Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		map.put(&amp;quot;form_code&amp;quot;, &amp;quot;QuerysDeviceChannels&amp;quot;);
		map.put(&amp;quot;appid&amp;quot;, &amp;quot;123456&amp;quot;);
		map.put(&amp;quot;appsecret&amp;quot;, &amp;quot;123&amp;quot;);
		map.put(&amp;quot;status&amp;quot;, &amp;quot;ALL&amp;quot;);
		map.put(&amp;quot;page_size&amp;quot;, &amp;quot;100&amp;quot;);
		map.put(&amp;quot;page_index&amp;quot;, &amp;quot;1&amp;quot;);
		map.put(&amp;quot;trade_id&amp;quot;, &amp;quot;12314&amp;quot;);
//        RerEntity rerEntity = new RerEntity(&amp;quot;QuerysDeviceChannels&amp;quot;,&amp;quot;123456&amp;quot;, &amp;quot;123&amp;quot;, &amp;quot;ALL&amp;quot;, &amp;quot;100&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;13214&amp;quot;);
//        String str = &amp;quot;{\n&amp;quot; +  //这样也行，不过麻烦且看起来不友好
//        		&amp;quot;	\&amp;quot;form_code\&amp;quot;:\&amp;quot;QuerysDeviceChannels\&amp;quot;,\n&amp;quot; + 
//        		&amp;quot;	\&amp;quot;appid\&amp;quot;:\&amp;quot;123456\&amp;quot;,\n&amp;quot; + 
//        		&amp;quot;	\&amp;quot;appsecret\&amp;quot;:\&amp;quot;123\&amp;quot;,\n&amp;quot; + 
//        		&amp;quot;	\&amp;quot;status\&amp;quot;:\&amp;quot;ALL\&amp;quot;,\n&amp;quot; + 
//        		&amp;quot;	\&amp;quot;page_size\&amp;quot;:1000,\n&amp;quot; + 
//        		&amp;quot;	\&amp;quot;page_index\&amp;quot;:\&amp;quot;789\&amp;quot;,\n&amp;quot; + 
//        		&amp;quot;	\&amp;quot;trade_id\&amp;quot;:12314\n&amp;quot; + 
//        		&amp;quot;}&amp;quot;;
		HttpEntity&amp;lt;String&amp;gt; entity = new HttpEntity&amp;lt;&amp;gt;(JSONObject.toJSON(map).toString(),headers);
		JSONObject json = restTemplate.postForEntity(&amp;quot;http://127.0.0.1:8092/OutDataApi&amp;quot;, entity, JSONObject.class).getBody();
//		ResponseEntity&amp;lt;String&amp;gt; postForEntity = restTemplate.postForEntity(&amp;quot;http://127.0.0.1:8092/OutDataApi&amp;quot;, entity, String.class);
		return json.toString();
	}
   
	public String test2() {
		HttpHeaders headers = new HttpHeaders();
       MediaType type = MediaType.parseMediaType(&amp;quot;application/x-www-form-urlencoded; charset=UTF-8&amp;quot;);
       headers.setContentType(type);
//        headers.add(&amp;quot;Accept&amp;quot;, &amp;quot;*/*&amp;quot;);
		String url = &amp;quot;http://localhost:8099/camera/status&amp;quot;;
//		JSONObject map = new JSONObject(); //这种方式传参，后端也许不能接收
//		map.put(&amp;quot;page&amp;quot;, &amp;quot;1&amp;quot;);
//		map.put(&amp;quot;pageSize&amp;quot;, &amp;quot;50&amp;quot;);
//		map.put(&amp;quot;status&amp;quot;, &amp;quot;off&amp;quot;);
//		map.put(&amp;quot;isShareIdCanBeNull&amp;quot;, &amp;quot;false&amp;quot;);
		MultiValueMap&amp;lt;String, String&amp;gt; requestParam = new LinkedMultiValueMap&amp;lt;&amp;gt;(); //部分情况下，这种方式传参，后端才能接受
		requestParam.set(&amp;quot;page&amp;quot;, &amp;quot;1&amp;quot;);
		requestParam.set(&amp;quot;pageSize&amp;quot;, &amp;quot;50&amp;quot;);
		requestParam.set(&amp;quot;status&amp;quot;, &amp;quot;off&amp;quot;);
		requestParam.set(&amp;quot;isShareIdCanBeNull&amp;quot;, &amp;quot;false&amp;quot;);
//		CameraEntity cameraEntity = new CameraEntity(&amp;quot;1&amp;quot;, &amp;quot;50&amp;quot;, &amp;quot;off&amp;quot;, &amp;quot;false&amp;quot;);
   		
		//如果要设置请求头，就用HttpEntity，不需要设置请求头就直接用请求参数代替HttpEntity
		HttpEntity&amp;lt;MultiValueMap&amp;lt;String, String&amp;gt;&amp;gt; entity = new HttpEntity&amp;lt;&amp;gt;(requestParam,headers);
		JSONObject json = restTemplate.postForObject(url, entity, JSONObject.class);
		return json.toString();
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;1）&lt;code&gt;http://127.0.0.1:8092/OutDataApi&lt;/code&gt;这个请求的请求体必须是json格式，controller中请求参数添加&lt;code&gt;@RequestBody&lt;/code&gt;注解的http请求&lt;/p&gt;

&lt;p&gt;2）&lt;code&gt;http://127.0.0.1:8092/OutDataApi&lt;/code&gt;这个请求的controller中请求参数为多个对象组成，如下面接口.如果要设置请求头，应使用&lt;code&gt;HttpEntity&amp;lt;MultiValueMap&amp;lt;String, Object&amp;gt;&amp;gt; entity = new HttpEntity&amp;lt;&amp;gt;(requestParam,headers);&lt;/code&gt;,如果不设置请求头，则可以直接使用请求对象当参数&lt;code&gt;JSONObject json = restTemplate.postForObject(url, requestParam, JSONObject.class);&lt;/code&gt;,其中&lt;code&gt;requestParam&lt;/code&gt;必须是&lt;code&gt;MultiValueMap&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;3）如果需要在返回结果中获取请求状态码、请求头等内容，则可以使用&lt;code&gt;xxxForEntity&lt;/code&gt;方式发生请求，如果只需要获取请求返回的结果，则可以使用&lt;code&gt;xxxForObject&lt;/code&gt;发生请求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;   @ResponseBody
   	@RequestMapping(&amp;quot;/status&amp;quot;)
   	public AjaxMessageResult&amp;lt;Object&amp;gt; getCameraByStatus(
   			@Validated({ SetPageValidate.class, SetStatusValidate.class }) ReqCamera cameraBo, ReqPage reqPage, BindingResult result) throws Exception {
   		if (result.hasErrors()) {
   			return new AjaxInvalidResult(result);
   		}
           ......
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-4-http请求转化器&#34;&gt;5.4 HTTP请求转化器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
	 * 配置Http请求转换器
	 * @return
	 */
	@Bean
	@ConditionalOnMissingBean
	public HttpMessageConverters fastjsonConverter() {
		FastJsonConfig fastJsonConfig = new FastJsonConfig();
		// 自定义格式化输出
//		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat, SerializerFeature.WriteNullStringAsEmpty,
//				SerializerFeature.WriteNullNumberAsZero); // 会将null值写成空字符串
		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat, SerializerFeature.WriteNullNumberAsZero);

		FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
		// 中文乱码解决方案
        List&amp;lt;MediaType&amp;gt; mediaTypes = new ArrayList&amp;lt;&amp;gt;();
        mediaTypes.add(MediaType.APPLICATION_JSON_UTF8);//设定json格式且编码为UTF-8
        fastJsonHttpMessageConverter.setSupportedMediaTypes(mediaTypes);
		
        fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);
        
		return new HttpMessageConverters(fastJsonHttpMessageConverter);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-5-启动前执行方法的几种方式&#34;&gt;5.5 启动前执行方法的几种方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用@PostConstruct注解&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;InitializingBean&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上几种初始化方法，执行顺序依次为 &lt;code&gt;@PostConstruct&amp;lt;-InitializingBean&amp;lt;-BeanPostProcessor&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;6-quartz任务调度&#34;&gt;6. Quartz任务调度&lt;/h1&gt;

&lt;h2 id=&#34;6-1-基本对象&#34;&gt;6.1 基本对象&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Scheduler:&lt;/code&gt;调度器。所有的调度都是由它控制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Trigger:&lt;/code&gt; 定义触发的条件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Job:&lt;/code&gt; 包含真正的执行逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JobDetail :&lt;/code&gt; 定义任务数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;job &amp;amp; jobdetail：&lt;/code&gt; JobDetail &amp;amp; Job 方式，sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。  使用任务调度+事件的方式可以实现许多复杂的功能。&lt;/p&gt;

&lt;h1 id=&#34;7-redis-入门&#34;&gt;7. Redis 入门&lt;/h1&gt;

&lt;h2 id=&#34;7-1-redis基本数据类型&#34;&gt;7.1 redis基本数据类型&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;数据类型存储的值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;可以保持字符串、整数、浮点数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td&gt;链表，链表的每个节点可以保存字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Set&lt;/td&gt;
&lt;td&gt;无序集合，集合里的每个元素都是字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Hash&lt;/td&gt;
&lt;td&gt;类似java中的map，是一个键值对应的无序列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Zset&lt;/td&gt;
&lt;td&gt;有序集合，可以包含字符串、整数、浮点数、分值（score），元素的排序是依据分值的大小来决定的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HyperLogLog&lt;/td&gt;
&lt;td&gt;它的作用是计算重复的值，以确定存储的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;7-2-常用命令&#34;&gt;7.2 常用命令&lt;/h2&gt;

&lt;h3 id=&#34;7-2-1-字符串&#34;&gt;7.2.1 字符串&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;redis命令&lt;/th&gt;
&lt;th&gt;spring中操作命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;set key value&lt;/td&gt;
&lt;td&gt;set(key, value)&lt;/td&gt;
&lt;td&gt;设置键值对&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;get key&lt;/td&gt;
&lt;td&gt;get(key)&lt;/td&gt;
&lt;td&gt;根据key获取值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;del key&lt;/td&gt;
&lt;td&gt;delete(key)&lt;/td&gt;
&lt;td&gt;通过key删除值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;strlen key&lt;/td&gt;
&lt;td&gt;size(key)&lt;/td&gt;
&lt;td&gt;求key指向字符串的长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;getset key value&lt;/td&gt;
&lt;td&gt;getAndSet(key, value)&lt;/td&gt;
&lt;td&gt;修改原来key对应的值，并将旧值返回&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;getrange key start end&lt;/td&gt;
&lt;td&gt;get(key, start, end)&lt;/td&gt;
&lt;td&gt;获取子串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;append key value&lt;/td&gt;
&lt;td&gt;append(key, value)&lt;/td&gt;
&lt;td&gt;将新字符串加入到原来key指向的字符串末&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;incr key&lt;/td&gt;
&lt;td&gt;increment(key, 1)&lt;/td&gt;
&lt;td&gt;原字段加1        （整数有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;incrby key increment&lt;/td&gt;
&lt;td&gt;increment(key, value)&lt;/td&gt;
&lt;td&gt;原字段加整数     （整数有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;decr key&lt;/td&gt;
&lt;td&gt;&lt;code&gt;查看备注&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;原字段减1     （整数有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;decr key increment&lt;/td&gt;
&lt;td&gt;&lt;code&gt;查看备注&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;原字段减去整数     （整数有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;incrbyfloat keyincrement&lt;/td&gt;
&lt;td&gt;increment(key, value)&lt;/td&gt;
&lt;td&gt;原字段加上浮点数     （整数或浮点数都&lt;strong&gt;有效&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;注：&lt;/code&gt;&lt;/strong&gt; spring已经对加法进行了封装，因此&lt;code&gt;increment（key, value）&lt;/code&gt;方法不仅可以支持整数，还可以支持long/double等数据类型的加法操作，对于减法，参考如下代码段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;redisTemplate.getConnectionFactory().getConnection().decrBy(
	redisTemplate.getKeySerializer().serialize(key), value
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是对于以上代码的减法操作，被减数，即key上的原有值只能是整数不能是浮点数，否则可能会产生异常。&lt;/p&gt;

&lt;h3 id=&#34;7-2-2-哈希&#34;&gt;7.2.2 哈希&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;redis命令&lt;/th&gt;
&lt;th&gt;spring命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HMSet key field1 value1 [field2 value2 ]&lt;/td&gt;
&lt;td&gt;putAll(key, map)&lt;/td&gt;
&lt;td&gt;同时将多个 field-value (域-值)对设置到哈希表 key 中。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HSet key field value&lt;/td&gt;
&lt;td&gt;put(key, field, value)&lt;/td&gt;
&lt;td&gt;将哈希表 key 中的字段 field 的值设为 value 。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HSetNx key field value&lt;/td&gt;
&lt;td&gt;putIfAbsent(key, field, value)&lt;/td&gt;
&lt;td&gt;只有在字段 field 不存在时，设置哈希表字段的值。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HVals key&lt;/td&gt;
&lt;td&gt;values(key)&lt;/td&gt;
&lt;td&gt;获取哈希表中所有值,返回list&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HLen key&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;获取哈希表中字段的数量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HKeys key&lt;/td&gt;
&lt;td&gt;keys(key)&lt;/td&gt;
&lt;td&gt;获取所有哈希表中的字段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HIncrBy key field increment&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为哈希表 key 中的指定字段的整数值加上增量 increment 。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HMGet key field1 [field2 ]&lt;/td&gt;
&lt;td&gt;multiGet(key, keyList)&lt;/td&gt;
&lt;td&gt;获取所有给定字段的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HGetAll key&lt;/td&gt;
&lt;td&gt;entries(key)&lt;/td&gt;
&lt;td&gt;获取在哈希表中指定 key 的所有字段和值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HSCAN key cursor [MATCH pattern] [COUNT count]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;迭代哈希表中的键值对。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HDelkey field1 [field2]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;删除一个或多个哈希表字段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HINCRBY key field increment&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;给hash表中某字段加上一个整数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HIncrByFloat key field increment&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;给hash表中某字段加上一个浮点数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Hexists key field&lt;/td&gt;
&lt;td&gt;hasKey(key,field)&lt;/td&gt;
&lt;td&gt;是否存在键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;8-关于sql&#34;&gt;8 关于SQL&lt;/h1&gt;

&lt;h2 id=&#34;8-1-常用sql&#34;&gt;8.1 常用sql&lt;/h2&gt;

&lt;h3 id=&#34;8-1-1-根据时间条件删除目标&#34;&gt;8.1.1 根据时间条件删除目标&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 其中 `now()` 是当前时间， `createtime`是数据库中的一个字段，即创建该字段的时间
DELETE from table_info WHERE DATEDIFF(now(),createtime) &amp;gt;7
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;9-数据转换&#34;&gt;9 数据转换&lt;/h1&gt;

&lt;h2 id=&#34;1-1-date转换&#34;&gt;1.1 Date转换&lt;/h2&gt;

&lt;h3 id=&#34;1-1-1-eee-mmm-dd-hh-mm-ss-z-yyyy格式date转换&#34;&gt;1.1.1 EEE MMM dd HH:mm:ss z yyyy格式Date转换&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;EEE MMM dd HH:mm:ss z yyyy&amp;quot;, Locale.US);
Date date = sdf.parse(&amp;quot;Sat Oct 12 07:38:06 CST 2019&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>docker的简单使用</title>
      <link>https://hisaige.github.io/post/development/dorcker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hisaige.github.io/post/development/dorcker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      
        <description>

&lt;h1&gt;docker的简单使用&lt;/h1&gt;

&lt;h2 id=&#34;1-安装&#34;&gt;1. 安装&lt;/h2&gt;

&lt;p&gt;1.如果装了新版本，先卸载旧版&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装所需的包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install -y yum-utils \
device-mapper-persistent-data \
lvm2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置&lt;strong&gt;稳定&lt;/strong&gt;存储库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# docker切换阿里源（生产环境慎重）
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

# 使用官方推荐的存储库，由于是国外网站，卡慢
sudo yum-config-manager \
--add-repo \
https://download.docker.com/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装最新版&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo yum install docker-ce docker-ce-cli containerd.io

# 安装完毕后，可以使用以下命令查看docker版本
docker version
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置阿里云镜像加速和本地工作目录&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​   ①添加并配置 /etc/docker/daemon.json 文件。&lt;/p&gt;

&lt;p&gt;​   ②修改配置文件内容为, &lt;code&gt;/usr/local/docker&lt;/code&gt; 是工作目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;{
&amp;quot;data-root&amp;quot;: &amp;quot;/usr/local/docker&amp;quot;,
&amp;quot;registry-mirrors&amp;quot;: [
&amp;quot;https://kfwkfulq.mirror.aliyuncs.com&amp;quot;,
&amp;quot;https://2lqq34jg.mirror.aliyuncs.com&amp;quot;,
&amp;quot;https://aa25jngu.mirror.aliyuncs.com&amp;quot;,
&amp;quot;https://registry.docker-cn.com&amp;quot;
]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-使用docker&#34;&gt;2. 使用docker&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;万物皆起于 &lt;code&gt;hello-world&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1.拉取hello-world镜像
docker pull hello-world

# 2.运行hello-world
docker run hello-world

# 3.运行时如果出现以下文字，说明hello-world运行成功
[root@localhost docker]# docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the &amp;quot;hello-world&amp;quot; image from the Docker Hub.
(amd64)
3. The Docker daemon created a new container from that image which runs the
executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
$ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
https://hub.docker.com/

For more examples and ideas, visit:
https://docs.docker.com/get-started/
#运行成功
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;镜像常用命令&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; ：列出本地所有的镜像（含中间映像层）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-q&lt;/code&gt; :  只显示镜像ID&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--digests&lt;/code&gt; : 显示镜像的摘要信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--no-trunc&lt;/code&gt; : 显示完整的镜像信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1.帮助信息
docker --help

# 2.显示所有镜像信息
docker images

# 3.去docker仓库查找镜像
docker search xxx镜像名
# 显示前两条
docker search tomcat -limit 2
#显示stars超过2000的
docker search tomcat --filter=stars=2000


# 4.删除镜像, 以下 镜像id 可以换成 镜像名 -f强制删除
docker rmi -f 镜像ID
#删除多个
docker rmi -f 镜像id1 镜像id2 镜像id3 ...
#删除全部
docker rmi -f $(docker images -q)

# 5. 删除容器 -f强制删除 -a全部容器 -q 返回容器id
docker rm 容器ID
# 删除全部容器
docker rm $(docker ps -aq)


&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;容器常用命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1.新建启动容器
docker run 容器名/容器id
#启动容器
docker start 容器id或容器名
## --name=&amp;quot;容器新名字&amp;quot; 为容器指定一个名称
## -d:后台运行容器，并返回容器id
## -i:以交互模式运行容器，通常与 -t 联合使用
## -t：为容器重新分配一个输入终端
## (以 -it 方式启动时会进入伪终端，推出伪终端并停止使用 exit 指令，退出伪终端不关闭容器快捷键ctrl+p+q)
## -P：随机端口映射
## -p:指定端口映射
		#通常有以下四种方式做映射
		#1. ip:port:containerPort
		#2. ip:containerPort
		#3. hostPort:containerPort
		#4.containerPort
		
# 2. 停止容器
docker stop 容器名或容器id
#强制停止
docker kill 容器id或容器名

# 3.删除容器 -f表示强制删除 -a表示关闭的容器 -q表示存活的容器
docker rm -f $(docker ps -a -q)
#或
docker ps -a -q | xargs docker rm

# 4.退出容器/进入容器
	#方式1 容器停止退出
	exit
	#方式2 容器不停止退出
	ctrl + p + q
#进入容器
	#方式1 进入终端
	docker attach 容器ID
	#方式2 不进入终端 直接执行容器的功能指令
	docker exec -t 镜像id 容器指令

# 5.查看容器日志
docker logs
# -t 加入时间戳
# -f 跟随最新的日志打印
# 	--tail 数字 显示最后多少条

# 6.从容器内拷贝文件到主机
docker cp 容器id:容器内路径 主机路径
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DockerFile保留字指令&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;build&lt;/th&gt;
&lt;th&gt;both&lt;/th&gt;
&lt;th&gt;run&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FROM&lt;/td&gt;
&lt;td&gt;WORKDIR&lt;/td&gt;
&lt;td&gt;CMD&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MAINTAINER&lt;/td&gt;
&lt;td&gt;USER&lt;/td&gt;
&lt;td&gt;ENV&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;COPY&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;EXPOSE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ADD&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;VOLUME&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RUN&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ENTRYPOINT&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ONBUILD&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.dockerignore&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;制作自定义linux镜像&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;n-linux随笔&#34;&gt;n. linux随笔&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;vim/vi编辑文件时退出方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;按ESC键 跳到命令模式，然后：

:w - 保存文件，不退出 vim
:w file -将修改另外保存到 file 中，不退出 vim
:w! -强制保存，不退出 vim
:wq -保存文件，退出 vim
:wq! -强制保存文件，退出 vim
:q -不保存文件，退出 vim
:q! -不保存文件，强制退出 vim
:e! -放弃所有修改，从上次保存文件开始再编辑
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常用系统指令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;重载系统服务(修改配置文件后需要做的事儿)：systemctl daemon-reload

设置开机启动：systemctl enable *.service

启动服务：systemctl start *.service

停止服务：systemctl stop *.service

重启服务：systemctl reload *.service
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>idea快捷键使用</title>
      <link>https://hisaige.github.io/post/tool/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hisaige.github.io/post/tool/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8/</guid>
      
        <description>

&lt;p&gt;&lt;center&gt;&lt;h1&gt;
    idea快捷键使用
&lt;/h1&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-快捷-键&#34;&gt;1. 快捷&lt;strong&gt;键&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ctrl + n  == 搜索类、方法、属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + shift + n == 搜索文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**ctrl + alt +n == 代码提示  **&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/  ctrl + alt + 空格 = 代码提示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alt + f7 == 查询在某处使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + q == 查看代码提示及内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + b  == 查看类的声明 ==ctrl+左键&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + f12  == 查看文件列表（类的方法列表）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + alt + ⬆/⬇ = 查看 父类/子类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + shift + ⬆/⬇ = 上移/下移一行代码&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连续两次shift  == 查找文件&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连安两下 shift 查找文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CtrL +shift +r 全局搜索&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl +r 搜索替换当前页的单词&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查看类继承关系图：Ctrl+Alt+U&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查看定义的变量在哪里被调用：Ctrl+Alt+F7&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查看Java方法调用树(被调/主调)：Ctrl+Alt+H&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**在codeStyle_java_import设置中，可以设置import多少个类自动变成import ***&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl +alt +v 自动生成返回值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + alt +t 生成环绕代码块 surround with&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctl + alt + &amp;lt;-  或 -&amp;gt;   上一步或下一步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + alt + m  抽取代码为方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + e 打开最近文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + h 查看类的继承关系&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctr + shift + u 大小写转化&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shift + enter 向下插入空行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + alt + enter 向上插入空行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;2-使用技巧&#34;&gt;2.使用技巧&lt;/h2&gt;

&lt;p&gt;debug篇&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;右键断点可以设置进入断点条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ctrl + u&lt;/strong&gt; 进入查看debug时表达式的值&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>rabbitMQ入门</title>
      <link>https://hisaige.github.io/post/development/rabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hisaige.github.io/post/development/rabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      
        <description>

&lt;h1&gt;RabbitMQ学习笔记&lt;/h1&gt;

&lt;h2 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;基本模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果使用默认方式接收队列，先启动多个监听者，再启动生产者，消费方式默认为轮询分发模式，不论监听者执行效率多少，都是轮询获取mq消息。使用多劳模式时，必须手动确认ack。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 能者多劳关键代码
//1. 在队列声明之后
channel.basicQos(1);
//2. 在消费之后
finally {
             channel.basicAck(envelope.getDeliveryTag(), false);
}
//3.定义消费者
channel.basicConsume(queueName, false, consumer);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;订阅模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;多个队列绑定到同一个交换机上，生产者将消息发送到交换机，由消费者订阅消息。&lt;/p&gt;

&lt;p&gt;注意exchange 类型 &lt;code&gt;type&lt;/code&gt;值为 &lt;code&gt;fanout&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//生产者
Connection connection = ConnectionUtils.getConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(exchange, &amp;quot;fanout&amp;quot;);
        channel.basicQos(1);

        for (int i = 0; i &amp;lt; 50; i++) {
            String msg = sendStr + i;
            channel.basicPublish(exchange, &amp;quot;&amp;quot;, null, msg.getBytes());
        }
        channel.close();
        connection.close();

//消费者
onnection connection = ConnectionUtils.getConnection();
        Channel channel = connection.createChannel();
        channel.queueDeclare(queueName, false, false, false, null);
        channel.queueBind(queueName, exchange, &amp;quot;&amp;quot;);
        channel.basicQos(1);
        Consumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String msg = new String(body, &amp;quot;utf-8&amp;quot;);
                ... ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;路由模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在声明exchange时，给予路由关键字，在在channel绑定exchange时，也声明路由，在生产者将数据投递到exchange上后，exchange根据路由关键字将数据投递给channel。&lt;/p&gt;

&lt;p&gt;注意exchange 类型 &lt;code&gt;type&lt;/code&gt;值为 &lt;code&gt;direct&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关键代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//生产者
 Connection connection = ConnectionUtils.getConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(exchange, &amp;quot;direct&amp;quot;);
        channel.basicQos(1);
        String routingKey = &amp;quot;error&amp;quot;;
        for (int i = 0; i &amp;lt; 50; i++) {
            String msg = sendStr + i;
            channel.basicPublish(exchange, routingKey, null, msg.getBytes());
        }
        channel.close();
        connection.close();


//消费者
String uuid = UUID.randomUUID().toString();
        System.out.println(&amp;quot;start consumer:&amp;quot; + uuid);
        Connection connection = ConnectionUtils.getConnection();
        Channel channel = connection.createChannel();
        channel.queueDeclare(queueName, false, false, false, null);
        // routKeys 是个list字符串数组
		routKeys.forEach(routKey -&amp;gt;{
            try {
                channel.queueBind(queueName, exchange, routKey);
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        channel.basicQos(1);
        Consumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String msg = new String(body, &amp;quot;utf-8&amp;quot;);
                ... ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;topic模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据routingKey上的通配符分发事件。&lt;code&gt;*&lt;/code&gt;代表匹配一个关键字，&lt;code&gt;#&lt;/code&gt;代表匹配多个关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//服务端
 channel.exchangeDeclare(exchange, &amp;quot;topic&amp;quot;);
        channel.basicQos(1);
        String routingKey = &amp;quot;goods，type.add&amp;quot;;
        for (int i = 0; i &amp;lt; 50; i++) {
            String msg = sendStr + i;
            channel.basicPublish(exchange, routingKey, null, msg.getBytes());
        }

//客户端1,queueName队列可以收到消息
channel.exchangeDeclare(exchange, &amp;quot;topic&amp;quot;);
channel.queueDeclare(queueName, false, false, false, null);
channel.queueBind(queueName, exchange, &amp;quot;goods.*.add&amp;quot;);

//客户端2,queueName队列可以收到消息
channel.exchangeDeclare(exchange, &amp;quot;topic&amp;quot;);
channel.queueDeclare(queueName, false, false, false, null);
channel.queueBind(queueName, exchange, &amp;quot;goods.#&amp;quot;);

//客户端3,queueName队列不可以收到消息
channel.exchangeDeclare(exchange, &amp;quot;topic&amp;quot;);
channel.queueDeclare(queueName, false, false, false, null);
channel.queueBind(queueName, exchange, &amp;quot;goods.type.delete&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;事务确认机制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过事务控制操作mq队列，关键代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;try{
                channel.txSelect();
                channel.basicPublish(&amp;quot;&amp;quot;, queueName, null, msg.getBytes());
                //如果抛出异常，事件不发送到mq
                //int a = 1/0;
                channel.txCommit();
            }catch (Exception e){
                System.out.println(&amp;quot;channel rollback...&amp;quot;);
                channel.txRollback();
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;单条/多条 conform 模式确认机制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了保证消息投递的正确无误，有时候需要对消息进行确认是否投递成功，失败后做相应的异常处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//方式1 单条 confirm
//生产者开启confirm模式
public static void send(String queueName, String sendStr) throws IOException, TimeoutException {

    Connection connection = ConnectionUtils.getConnection();
    Channel channel = connection.createChannel();
    channel.queueDeclare(queueName, false, false, false, null);
    //        channel.basicQos(1);
    //生产者开启confirm模式
    channel.confirmSelect();
    for (int i = 0; i &amp;lt; 50; i++) {
        String msg = sendStr + i;

        channel.basicPublish(&amp;quot;&amp;quot;, queueName, null, msg.getBytes());

        try{
            if(channel.waitForConfirms()){
                System.out.println(&amp;quot;消息发送成功&amp;quot;);
            } else{
                System.out.println(&amp;quot;消息发送失败&amp;quot;);
            }
        } catch (Exception e){
            e.printStackTrace();
        }

    }
    channel.close();
    connection.close();
}
// 方式1 单条confitm消费者
public static void handleDelivery(String queueName) throws IOException, TimeoutException {

    String uuid = UUID.randomUUID().toString();
    System.out.println(&amp;quot;start consumer:&amp;quot; + uuid);
    Connection connection = ConnectionUtils.getConnection();
    Channel channel = connection.createChannel();
    channel.queueDeclare(queueName, false, false, false, null);
    channel.basicQos(1);
    Consumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
            String msg = new String(body, &amp;quot;utf-8&amp;quot;);
            System.out.println(uuid + &amp;quot;接收到消息——&amp;quot; + msg);
            try {
                Thread.sleep(Math.round(Math.random()*3000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                channel.basicAck(envelope.getDeliveryTag(), false);
            }
        }
    };
    channel.basicConsume(queueName, false, consumer);
}

//方式2 批量confirm
//生产者开启confirm模式
public static void send(String queueName, String sendStr) throws IOException, TimeoutException {

    Connection connection = ConnectionUtils.getConnection();
    Channel channel = connection.createChannel();
    channel.queueDeclare(queueName, false, false, false, null);
    //        channel.basicQos(1);
    channel.confirmSelect();
    channel.addConfirmListener(new ConfirmListener() {
        @Override
        public void handleAck(long deliveryTag, boolean multiple) throws IOException {
            if(multiple){
                System.out.println(&amp;quot;发送多条成功:&amp;quot; + deliveryTag);
                confirmSet.headSet(deliveryTag + 1).clear();
            } else {
                System.out.println(&amp;quot;发送1条成功:&amp;quot; + deliveryTag);
                confirmSet.remove(deliveryTag);
            }
        }

        @Override
        public void handleNack(long deliveryTag, boolean multiple) throws IOException {
            if(multiple){
                System.out.println(&amp;quot;发送多条失败:&amp;quot; + deliveryTag);
                confirmSet.headSet(deliveryTag + 1).clear();
            } else {
                System.out.println(&amp;quot;发送1条失败:&amp;quot; + deliveryTag);
                confirmSet.remove(deliveryTag);
            }
        }
    });
    for (int i = 0; i &amp;lt; 50; i++) {
        String msg = sendStr + i;
        long seqNo = channel.getNextPublishSeqNo();
        channel.basicPublish(&amp;quot;&amp;quot;, queueName, null, msg.getBytes());
        confirmSet.add(seqNo);
    }
    channel.close();
    connection.close();
}

//方式2 批量confitm消费者
public static void handleDelivery(String queueName) throws IOException, TimeoutException {

    String uuid = UUID.randomUUID().toString();
    System.out.println(&amp;quot;start consumer:&amp;quot; + uuid);
    Connection connection = ConnectionUtils.getConnection();
    Channel channel = connection.createChannel();
    channel.queueDeclare(queueName, false, false, false, null);
    channel.basicQos(1);
    channel.confirmSelect();
    channel.addConfirmListener(new ConfirmListener() {
        @Override
        public void handleAck(long deliveryTag, boolean multiple) throws IOException {
            if(multiple){
                System.out.println(&amp;quot;接收多条成功:&amp;quot; + deliveryTag);
                confirmSet.headSet(deliveryTag + 1).clear();
            } else {
                System.out.println(&amp;quot;接收1条成功:&amp;quot; + deliveryTag);
                confirmSet.remove(deliveryTag);
            }
        }

        @Override
        public void handleNack(long deliveryTag, boolean multiple) throws IOException {
            if(multiple){
                System.out.println(&amp;quot;接收多条失败:&amp;quot; + deliveryTag);
                confirmSet.headSet(deliveryTag + 1).clear();
            } else {
                System.out.println(&amp;quot;接收1条失败:&amp;quot; + deliveryTag);
                confirmSet.remove(deliveryTag);
            }
        }
    });
    Consumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
            String msg = new String(body, &amp;quot;utf-8&amp;quot;);
            System.out.println(uuid + &amp;quot;接收到消息——&amp;quot; + msg );
            try {
                Thread.sleep(Math.round(Math.random()*2000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                channel.basicAck(envelope.getDeliveryTag(), false);
            }
        }
    };
    channel.basicConsume(queueName, false, consumer);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>数据源配置</title>
      <link>https://hisaige.github.io/post/development/druid%E4%B8%A4%E7%A7%8D%E6%AF%94%E8%BE%83%E7%A8%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hisaige.github.io/post/development/druid%E4%B8%A4%E7%A7%8D%E6%AF%94%E8%BE%83%E7%A8%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/</guid>
      
        <description>

&lt;h1&gt;数据库之druid的两种配置方式&lt;/h1&gt;

&lt;h1 id=&#34;1-方式一&#34;&gt;1. 方式一&lt;/h1&gt;

&lt;p&gt;pom如下，注意druid用的版本是1.1.18，低版本可能不适用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;		&amp;lt;!-- 分页插件 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pagehelper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;tk.mybatis&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mapper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.1.5&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&amp;gt;
        &amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&amp;gt;
        &amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1.18&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java\&#34;&gt;package com.hisaige.database.config;

import com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties;
import com.alibaba.druid.support.http.StatViewServlet;
import com.alibaba.druid.support.http.WebStatFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

import javax.sql.DataSource;
import java.sql.SQLException;

@Configuration
public class DataSourceConfiguration {



	@Resource
	private DataSource dataSource;

	/*
	 * @Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource)
	 * throws Exception { SqlSessionFactoryBean factory = new
	 * SqlSessionFactoryBean(); factory.setDataSource(dataSource); return
	 * factory.getObject(); }
	 */

	@Bean
	public DataSourceTransactionManager transactionManager() throws SQLException {
		DataSourceTransactionManager transManager = new DataSourceTransactionManager();
		transManager.setDataSource(dataSource);
		return transManager;
	}
	
	/**
	*分页插件配置，
	*注意，如果分页插件要结合通用mapper使用的话，不要用分页插件的startter继承方式
	*如下这种普通方式即可，因为分页插件的startter里面继承了mybatis的自动装配startter，
	*这里面针对于mapper包扫描那块会出现冲突
	*
	*/
	@Bean
	public PageHelper pageHelper() {
		PageHelper pageHelper = new PageHelper();
		Properties props = new Properties();
		props.setProperty(&amp;quot;dialect&amp;quot;, &amp;quot;mysql&amp;quot;);
		// 表示支持从接口中读取pageNum和pageSize
		props.setProperty(&amp;quot;supportMethodsArguments&amp;quot;, &amp;quot;true&amp;quot;);
		pageHelper.setProperties(props);
		return pageHelper;
	}

	/**
	 * 配置监控服务器
	 * 
	 * @return 返回监控注册的servlet对象
	 * @author SimpleWu
	 */
	@Bean
	public ServletRegistrationBean&amp;lt;StatViewServlet&amp;gt; statViewServlet() {

		// 这里也可以通过读取yml配置文件的方式读取配置信息来设置黑白名单
		System.out.println(&amp;quot;------------userName&amp;quot; + druidStatProperties.getStatViewServlet().getLoginUsername());

		ServletRegistrationBean&amp;lt;StatViewServlet&amp;gt; servletRegistrationBean = new ServletRegistrationBean&amp;lt;&amp;gt;(
				new StatViewServlet(), &amp;quot;/druid/*&amp;quot;);
		// 添加IP白名单
		servletRegistrationBean.addInitParameter(&amp;quot;allow&amp;quot;, &amp;quot;127.0.0.1&amp;quot;); // 本机使用IP将不能访问，但可以使用localhost作IP访问
		// 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高
		servletRegistrationBean.addInitParameter(&amp;quot;deny&amp;quot;, &amp;quot;192.16.13.243&amp;quot;);
		// 添加控制台管理用户
		servletRegistrationBean.addInitParameter(&amp;quot;loginUsername&amp;quot;, &amp;quot;admin&amp;quot;);
		servletRegistrationBean.addInitParameter(&amp;quot;loginPassword&amp;quot;, &amp;quot;admin&amp;quot;);
		// 是否能够重置数据
		servletRegistrationBean.addInitParameter(&amp;quot;resetEnable&amp;quot;, &amp;quot;true&amp;quot;);
		return servletRegistrationBean;
	}

	/**
	 * 配置服务过滤器
	 *
	 * @return 返回过滤器配置对象
	 */
	@Bean
	public FilterRegistrationBean&amp;lt;WebStatFilter&amp;gt; statFilter() {
		FilterRegistrationBean&amp;lt;WebStatFilter&amp;gt; filterRegistrationBean = new FilterRegistrationBean&amp;lt;&amp;gt;(
				new WebStatFilter());
		// 添加过滤规则
		filterRegistrationBean.addUrlPatterns(&amp;quot;/*&amp;quot;);
		// 忽略过滤格式
		filterRegistrationBean.addInitParameter(&amp;quot;exclusions&amp;quot;, &amp;quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&amp;quot;);
		return filterRegistrationBean;
	}

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;yml配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3316/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=UTC
    username: root
    password: cyj515818
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      # 下面为连接池的补充设置，应用到上面所有数据源中      # 初始化大小，最小，最大
      initial-size: 5
      min-idle: 5
      max-active: 20
      # 配置获取连接等待超时的时间
      max-wait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
      time-between-eviction-runs-millis: 60000
      # 配置一个连接在池中最小生存的时间，单位是毫秒
      min-evictable-idle-time-millis: 300000
      validation-query: SELECT 1 FROM DUAL
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      # 打开PSCache，并且指定每个连接上PSCache的大小
      pool-prepared-statements: true
      #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙
      max-pool-prepared-statement-per-connection-size: 20
      filters: stat,wall
      use-global-data-source-stat: true
      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
      connect-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
      # 配置监控服务器,目前下面这种配置在1.1.10可以，高版本比如1.1.16不行,
      # 目前使用的是较高版本，所以先注释，使用DataSourceConfiguration中的注释代替
      keep-alive: true
      stat-view-servlet:
        login-username: admin
        login-password: 123456
        reset-enable: false
        url-pattern: /druid/*
        # 添加IP白名单
        allow: 127.0.0.1
        # 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高
        deny: 192.168.1.3
      #配置过滤规则
      web-stat-filter:
        # 添加过滤规则
        url-pattern: /*
        # 忽略过滤格式
        exclusions: &amp;quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试分类插件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@Test
	public void test3(){
		PageHelper.startPage(2, 2);
		List&amp;lt;User&amp;gt; users=userMapper.selectAll();
		PageInfo&amp;lt;User&amp;gt; pageInfo = new PageInfo&amp;lt;&amp;gt;(users);
		System.out.println(pageInfo);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-配置方式二&#34;&gt;2. 配置方式二&lt;/h1&gt;

&lt;p&gt;配置二是一种比较稳妥的方式，避免duid版本改动时配置的方式发生变动而需要再修改druid相关配置。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先定义一个包含druid绝大部分配置属性的properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.hisaige.database.config.data;

import java.io.PrintWriter;
import java.sql.Driver;
import java.util.Date;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.PasswordCallback;

import com.alibaba.druid.pool.DruidPooledConnection;
import com.alibaba.druid.pool.ExceptionSorter;
import com.alibaba.druid.pool.ValidConnectionChecker;

public class DruidProperties {

	public final static int DEFAULT_INITIAL_SIZE = 0;
	public final static int DEFAULT_MAX_ACTIVE_SIZE = 8;
	public final static int DEFAULT_MAX_IDLE = 8;
	public final static int DEFAULT_MIN_IDLE = 0;
	public final static int DEFAULT_MAX_WAIT = -1;
	public final static String DEFAULT_VALIDATION_QUERY = null; //
	public final static boolean DEFAULT_TEST_ON_BORROW = false;
	public final static boolean DEFAULT_TEST_ON_RETURN = false;
	public final static boolean DEFAULT_WHILE_IDLE = true;
	public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = 60 * 1000L;
	public static final long DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS = 500;
	public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;

	public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
	public static final long DEFAULT_MAX_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 60L * 7;
	public static final long DEFAULT_PHY_TIMEOUT_MILLIS = -1;

	private volatile boolean defaultAutoCommit = true;
	private volatile Boolean defaultReadOnly;
	private volatile Integer defaultTransactionIsolation;
	private volatile String defaultCatalog = null;

	private volatile String username;
	private volatile String password;
	private volatile String jdbcUrl;
	private volatile String driverClass;
	private volatile ClassLoader driverClassLoader;
	private volatile Properties connectProperties = new Properties();

	private volatile PasswordCallback passwordCallback;
	private volatile NameCallback userCallback;

	private volatile int initialSize = DEFAULT_INITIAL_SIZE;
	private volatile int maxActive = DEFAULT_MAX_ACTIVE_SIZE;
	private volatile int minIdle = DEFAULT_MIN_IDLE;
	private volatile int maxIdle = DEFAULT_MAX_IDLE;
	private volatile long maxWait = DEFAULT_MAX_WAIT;
	private int notFullTimeoutRetryCount = 0;

	private volatile String validationQuery = DEFAULT_VALIDATION_QUERY;
	private volatile int validationQueryTimeout = -1;
	private volatile boolean testOnBorrow = DEFAULT_TEST_ON_BORROW;
	private volatile boolean testOnReturn = DEFAULT_TEST_ON_RETURN;
	private volatile boolean testWhileIdle = DEFAULT_WHILE_IDLE;
	private volatile boolean poolPreparedStatements = false;
	private volatile boolean sharePreparedStatements = false;
	private volatile boolean useGlobalDataSourceStat = true;
	private volatile int maxPoolPreparedStatementPerConnectionSize = 10;

	private volatile boolean inited = false;
	private volatile boolean initExceptionThrow = true;

	private PrintWriter logWriter = new PrintWriter(System.out);

	private volatile boolean clearFiltersEnable = true;
	private volatile ExceptionSorter exceptionSorter = null;

	private Driver driver;

	private volatile int queryTimeout;
	private volatile int transactionQueryTimeout;

	private long createTimespan;

	private volatile int maxWaitThreadCount = -1;
	private volatile boolean accessToUnderlyingConnectionAllowed = true;

	private volatile long timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
	private volatile int numTestsPerEvictionRun = DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
	private volatile long minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
	private volatile long maxEvictableIdleTimeMillis = DEFAULT_MAX_EVICTABLE_IDLE_TIME_MILLIS;
	private volatile long keepAliveBetweenTimeMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS * 2;
	private volatile long phyTimeoutMillis = DEFAULT_PHY_TIMEOUT_MILLIS;
	private volatile long phyMaxUseCount = -1;

	private volatile boolean removeAbandoned;
	private volatile long removeAbandonedTimeoutMillis = 300 * 1000;
	private volatile boolean logAbandoned;

	private volatile int maxOpenPreparedStatements = -1;

	private volatile List&amp;lt;String&amp;gt; connectionInitSqls;

	private volatile String dbType;

	private volatile long timeBetweenConnectErrorMillis = DEFAULT_TIME_BETWEEN_CONNECT_ERROR_MILLIS;

	private volatile ValidConnectionChecker validConnectionChecker = null;

	private final Map&amp;lt;DruidPooledConnection, Object&amp;gt; activeConnections = new IdentityHashMap&amp;lt;DruidPooledConnection, Object&amp;gt;();

	private long id;

	private int connectionErrorRetryAttempts = 1;
	private boolean breakAfterAcquireFailure = false;
	private long transactionThresholdMillis = 0L;

	private Date initedTime;
	private volatile long errorCount = 0L;
	private volatile long dupCloseCount = 0L;
	private volatile long startTransactionCount = 0L;
	private volatile long commitCount = 0L;
	private volatile long rollbackCount = 0L;
	private volatile long cachedPreparedStatementHitCount = 0L;
	private volatile long preparedStatementCount = 0L;
	private volatile long closedPreparedStatementCount = 0L;
	private volatile long cachedPreparedStatementCount = 0L;
	private volatile long cachedPreparedStatementDeleteCount = 0L;
	private volatile long cachedPreparedStatementMissCount = 0L;

	private boolean dupCloseLogEnable = false;

	private volatile long executeCount = 0L;
	private volatile long executeQueryCount = 0L;
	private volatile long executeUpdateCount = 0L;
	private volatile long executeBatchCount = 0L;

	private volatile Throwable createError;
	private volatile Throwable lastError;
	private volatile long lastErrorTimeMillis;
	private volatile Throwable lastCreateError;
	private volatile long lastCreateErrorTimeMillis;
	private volatile long lastCreateStartTimeMillis;

	private boolean isOracle = false;
	private boolean isMySql = false;
	private boolean useOracleImplicitCache = true;

	private ReentrantLock lock;
	private Condition notEmpty;
	private Condition empty;

	private ReentrantLock activeConnectionLock = new ReentrantLock();

	private volatile int createErrorCount = 0;
	private volatile int creatingCount = 0;
	private volatile int directCreateCount = 0;
	private volatile long createCount = 0L;
	private volatile long destroyCount = 0L;
	private volatile long createStartNanos = 0L;
	public boolean isDefaultAutoCommit() {
		return defaultAutoCommit;
	}
	public void setDefaultAutoCommit(boolean defaultAutoCommit) {
		this.defaultAutoCommit = defaultAutoCommit;
	}
	public Boolean getDefaultReadOnly() {
		return defaultReadOnly;
	}
	public void setDefaultReadOnly(Boolean defaultReadOnly) {
		this.defaultReadOnly = defaultReadOnly;
	}
	public Integer getDefaultTransactionIsolation() {
		return defaultTransactionIsolation;
	}
	public void setDefaultTransactionIsolation(Integer defaultTransactionIsolation) {
		this.defaultTransactionIsolation = defaultTransactionIsolation;
	}
	public String getDefaultCatalog() {
		return defaultCatalog;
	}
	public void setDefaultCatalog(String defaultCatalog) {
		this.defaultCatalog = defaultCatalog;
	}
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public String getJdbcUrl() {
		return jdbcUrl;
	}
	public void setJdbcUrl(String jdbcUrl) {
		this.jdbcUrl = jdbcUrl;
	}
	public String getDriverClass() {
		return driverClass;
	}
	public void setDriverClass(String driverClass) {
		this.driverClass = driverClass;
	}
	public ClassLoader getDriverClassLoader() {
		return driverClassLoader;
	}
	public void setDriverClassLoader(ClassLoader driverClassLoader) {
		this.driverClassLoader = driverClassLoader;
	}
	public Properties getConnectProperties() {
		return connectProperties;
	}
	public void setConnectProperties(Properties connectProperties) {
		this.connectProperties = connectProperties;
	}
	public PasswordCallback getPasswordCallback() {
		return passwordCallback;
	}
	public void setPasswordCallback(PasswordCallback passwordCallback) {
		this.passwordCallback = passwordCallback;
	}
	public NameCallback getUserCallback() {
		return userCallback;
	}
	public void setUserCallback(NameCallback userCallback) {
		this.userCallback = userCallback;
	}
	public int getInitialSize() {
		return initialSize;
	}
	public void setInitialSize(int initialSize) {
		this.initialSize = initialSize;
	}
	public int getMaxActive() {
		return maxActive;
	}
	public void setMaxActive(int maxActive) {
		this.maxActive = maxActive;
	}
	public int getMinIdle() {
		return minIdle;
	}
	public void setMinIdle(int minIdle) {
		this.minIdle = minIdle;
	}
	public int getMaxIdle() {
		return maxIdle;
	}
	public void setMaxIdle(int maxIdle) {
		this.maxIdle = maxIdle;
	}
	public long getMaxWait() {
		return maxWait;
	}
	public void setMaxWait(long maxWait) {
		this.maxWait = maxWait;
	}
	public int getNotFullTimeoutRetryCount() {
		return notFullTimeoutRetryCount;
	}
	public void setNotFullTimeoutRetryCount(int notFullTimeoutRetryCount) {
		this.notFullTimeoutRetryCount = notFullTimeoutRetryCount;
	}
	public String getValidationQuery() {
		return validationQuery;
	}
	public void setValidationQuery(String validationQuery) {
		this.validationQuery = validationQuery;
	}
	public int getValidationQueryTimeout() {
		return validationQueryTimeout;
	}
	public void setValidationQueryTimeout(int validationQueryTimeout) {
		this.validationQueryTimeout = validationQueryTimeout;
	}
	public boolean isTestOnBorrow() {
		return testOnBorrow;
	}
	public void setTestOnBorrow(boolean testOnBorrow) {
		this.testOnBorrow = testOnBorrow;
	}
	public boolean isTestOnReturn() {
		return testOnReturn;
	}
	public void setTestOnReturn(boolean testOnReturn) {
		this.testOnReturn = testOnReturn;
	}
	public boolean isTestWhileIdle() {
		return testWhileIdle;
	}
	public void setTestWhileIdle(boolean testWhileIdle) {
		this.testWhileIdle = testWhileIdle;
	}
	public boolean isPoolPreparedStatements() {
		return poolPreparedStatements;
	}
	public void setPoolPreparedStatements(boolean poolPreparedStatements) {
		this.poolPreparedStatements = poolPreparedStatements;
	}
	public boolean isSharePreparedStatements() {
		return sharePreparedStatements;
	}
	public void setSharePreparedStatements(boolean sharePreparedStatements) {
		this.sharePreparedStatements = sharePreparedStatements;
	}
	public boolean isUseGlobalDataSourceStat() {
		return useGlobalDataSourceStat;
	}
	public void setUseGlobalDataSourceStat(boolean useGlobalDataSourceStat) {
		this.useGlobalDataSourceStat = useGlobalDataSourceStat;
	}
	public int getMaxPoolPreparedStatementPerConnectionSize() {
		return maxPoolPreparedStatementPerConnectionSize;
	}
	public void setMaxPoolPreparedStatementPerConnectionSize(int maxPoolPreparedStatementPerConnectionSize) {
		this.maxPoolPreparedStatementPerConnectionSize = maxPoolPreparedStatementPerConnectionSize;
	}
	public boolean isInited() {
		return inited;
	}
	public void setInited(boolean inited) {
		this.inited = inited;
	}
	public boolean isInitExceptionThrow() {
		return initExceptionThrow;
	}
	public void setInitExceptionThrow(boolean initExceptionThrow) {
		this.initExceptionThrow = initExceptionThrow;
	}
	public PrintWriter getLogWriter() {
		return logWriter;
	}
	public void setLogWriter(PrintWriter logWriter) {
		this.logWriter = logWriter;
	}
	public boolean isClearFiltersEnable() {
		return clearFiltersEnable;
	}
	public void setClearFiltersEnable(boolean clearFiltersEnable) {
		this.clearFiltersEnable = clearFiltersEnable;
	}
	public ExceptionSorter getExceptionSorter() {
		return exceptionSorter;
	}
	public void setExceptionSorter(ExceptionSorter exceptionSorter) {
		this.exceptionSorter = exceptionSorter;
	}
	public Driver getDriver() {
		return driver;
	}
	public void setDriver(Driver driver) {
		this.driver = driver;
	}
	public int getQueryTimeout() {
		return queryTimeout;
	}
	public void setQueryTimeout(int queryTimeout) {
		this.queryTimeout = queryTimeout;
	}
	public int getTransactionQueryTimeout() {
		return transactionQueryTimeout;
	}
	public void setTransactionQueryTimeout(int transactionQueryTimeout) {
		this.transactionQueryTimeout = transactionQueryTimeout;
	}
	public long getCreateTimespan() {
		return createTimespan;
	}
	public void setCreateTimespan(long createTimespan) {
		this.createTimespan = createTimespan;
	}
	public int getMaxWaitThreadCount() {
		return maxWaitThreadCount;
	}
	public void setMaxWaitThreadCount(int maxWaitThreadCount) {
		this.maxWaitThreadCount = maxWaitThreadCount;
	}
	public boolean isAccessToUnderlyingConnectionAllowed() {
		return accessToUnderlyingConnectionAllowed;
	}
	public void setAccessToUnderlyingConnectionAllowed(boolean accessToUnderlyingConnectionAllowed) {
		this.accessToUnderlyingConnectionAllowed = accessToUnderlyingConnectionAllowed;
	}
	public long getTimeBetweenEvictionRunsMillis() {
		return timeBetweenEvictionRunsMillis;
	}
	public void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
		this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
	}
	public int getNumTestsPerEvictionRun() {
		return numTestsPerEvictionRun;
	}
	public void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
		this.numTestsPerEvictionRun = numTestsPerEvictionRun;
	}
	public long getMinEvictableIdleTimeMillis() {
		return minEvictableIdleTimeMillis;
	}
	public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
		this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
	}
	public long getMaxEvictableIdleTimeMillis() {
		return maxEvictableIdleTimeMillis;
	}
	public void setMaxEvictableIdleTimeMillis(long maxEvictableIdleTimeMillis) {
		this.maxEvictableIdleTimeMillis = maxEvictableIdleTimeMillis;
	}
	public long getKeepAliveBetweenTimeMillis() {
		return keepAliveBetweenTimeMillis;
	}
	public void setKeepAliveBetweenTimeMillis(long keepAliveBetweenTimeMillis) {
		this.keepAliveBetweenTimeMillis = keepAliveBetweenTimeMillis;
	}
	public long getPhyTimeoutMillis() {
		return phyTimeoutMillis;
	}
	public void setPhyTimeoutMillis(long phyTimeoutMillis) {
		this.phyTimeoutMillis = phyTimeoutMillis;
	}
	public long getPhyMaxUseCount() {
		return phyMaxUseCount;
	}
	public void setPhyMaxUseCount(long phyMaxUseCount) {
		this.phyMaxUseCount = phyMaxUseCount;
	}
	public boolean isRemoveAbandoned() {
		return removeAbandoned;
	}
	public void setRemoveAbandoned(boolean removeAbandoned) {
		this.removeAbandoned = removeAbandoned;
	}
	public long getRemoveAbandonedTimeoutMillis() {
		return removeAbandonedTimeoutMillis;
	}
	public void setRemoveAbandonedTimeoutMillis(long removeAbandonedTimeoutMillis) {
		this.removeAbandonedTimeoutMillis = removeAbandonedTimeoutMillis;
	}
	public boolean isLogAbandoned() {
		return logAbandoned;
	}
	public void setLogAbandoned(boolean logAbandoned) {
		this.logAbandoned = logAbandoned;
	}
	public int getMaxOpenPreparedStatements() {
		return maxOpenPreparedStatements;
	}
	public void setMaxOpenPreparedStatements(int maxOpenPreparedStatements) {
		this.maxOpenPreparedStatements = maxOpenPreparedStatements;
	}
	public List&amp;lt;String&amp;gt; getConnectionInitSqls() {
		return connectionInitSqls;
	}
	public void setConnectionInitSqls(List&amp;lt;String&amp;gt; connectionInitSqls) {
		this.connectionInitSqls = connectionInitSqls;
	}
	public String getDbType() {
		return dbType;
	}
	public void setDbType(String dbType) {
		this.dbType = dbType;
	}
	public long getTimeBetweenConnectErrorMillis() {
		return timeBetweenConnectErrorMillis;
	}
	public void setTimeBetweenConnectErrorMillis(long timeBetweenConnectErrorMillis) {
		this.timeBetweenConnectErrorMillis = timeBetweenConnectErrorMillis;
	}
	public ValidConnectionChecker getValidConnectionChecker() {
		return validConnectionChecker;
	}
	public void setValidConnectionChecker(ValidConnectionChecker validConnectionChecker) {
		this.validConnectionChecker = validConnectionChecker;
	}
	public long getId() {
		return id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public int getConnectionErrorRetryAttempts() {
		return connectionErrorRetryAttempts;
	}
	public void setConnectionErrorRetryAttempts(int connectionErrorRetryAttempts) {
		this.connectionErrorRetryAttempts = connectionErrorRetryAttempts;
	}
	public boolean isBreakAfterAcquireFailure() {
		return breakAfterAcquireFailure;
	}
	public void setBreakAfterAcquireFailure(boolean breakAfterAcquireFailure) {
		this.breakAfterAcquireFailure = breakAfterAcquireFailure;
	}
	public long getTransactionThresholdMillis() {
		return transactionThresholdMillis;
	}
	public void setTransactionThresholdMillis(long transactionThresholdMillis) {
		this.transactionThresholdMillis = transactionThresholdMillis;
	}
	public Date getInitedTime() {
		return initedTime;
	}
	public void setInitedTime(Date initedTime) {
		this.initedTime = initedTime;
	}
	public long getErrorCount() {
		return errorCount;
	}
	public void setErrorCount(long errorCount) {
		this.errorCount = errorCount;
	}
	public long getDupCloseCount() {
		return dupCloseCount;
	}
	public void setDupCloseCount(long dupCloseCount) {
		this.dupCloseCount = dupCloseCount;
	}
	public long getStartTransactionCount() {
		return startTransactionCount;
	}
	public void setStartTransactionCount(long startTransactionCount) {
		this.startTransactionCount = startTransactionCount;
	}
	public long getCommitCount() {
		return commitCount;
	}
	public void setCommitCount(long commitCount) {
		this.commitCount = commitCount;
	}
	public long getRollbackCount() {
		return rollbackCount;
	}
	public void setRollbackCount(long rollbackCount) {
		this.rollbackCount = rollbackCount;
	}
	public long getCachedPreparedStatementHitCount() {
		return cachedPreparedStatementHitCount;
	}
	public void setCachedPreparedStatementHitCount(long cachedPreparedStatementHitCount) {
		this.cachedPreparedStatementHitCount = cachedPreparedStatementHitCount;
	}
	public long getPreparedStatementCount() {
		return preparedStatementCount;
	}
	public void setPreparedStatementCount(long preparedStatementCount) {
		this.preparedStatementCount = preparedStatementCount;
	}
	public long getClosedPreparedStatementCount() {
		return closedPreparedStatementCount;
	}
	public void setClosedPreparedStatementCount(long closedPreparedStatementCount) {
		this.closedPreparedStatementCount = closedPreparedStatementCount;
	}
	public long getCachedPreparedStatementCount() {
		return cachedPreparedStatementCount;
	}
	public void setCachedPreparedStatementCount(long cachedPreparedStatementCount) {
		this.cachedPreparedStatementCount = cachedPreparedStatementCount;
	}
	public long getCachedPreparedStatementDeleteCount() {
		return cachedPreparedStatementDeleteCount;
	}
	public void setCachedPreparedStatementDeleteCount(long cachedPreparedStatementDeleteCount) {
		this.cachedPreparedStatementDeleteCount = cachedPreparedStatementDeleteCount;
	}
	public long getCachedPreparedStatementMissCount() {
		return cachedPreparedStatementMissCount;
	}
	public void setCachedPreparedStatementMissCount(long cachedPreparedStatementMissCount) {
		this.cachedPreparedStatementMissCount = cachedPreparedStatementMissCount;
	}
	public boolean isDupCloseLogEnable() {
		return dupCloseLogEnable;
	}
	public void setDupCloseLogEnable(boolean dupCloseLogEnable) {
		this.dupCloseLogEnable = dupCloseLogEnable;
	}
	public long getExecuteCount() {
		return executeCount;
	}
	public void setExecuteCount(long executeCount) {
		this.executeCount = executeCount;
	}
	public long getExecuteQueryCount() {
		return executeQueryCount;
	}
	public void setExecuteQueryCount(long executeQueryCount) {
		this.executeQueryCount = executeQueryCount;
	}
	public long getExecuteUpdateCount() {
		return executeUpdateCount;
	}
	public void setExecuteUpdateCount(long executeUpdateCount) {
		this.executeUpdateCount = executeUpdateCount;
	}
	public long getExecuteBatchCount() {
		return executeBatchCount;
	}
	public void setExecuteBatchCount(long executeBatchCount) {
		this.executeBatchCount = executeBatchCount;
	}
	public Throwable getCreateError() {
		return createError;
	}
	public void setCreateError(Throwable createError) {
		this.createError = createError;
	}
	public Throwable getLastError() {
		return lastError;
	}
	public void setLastError(Throwable lastError) {
		this.lastError = lastError;
	}
	public long getLastErrorTimeMillis() {
		return lastErrorTimeMillis;
	}
	public void setLastErrorTimeMillis(long lastErrorTimeMillis) {
		this.lastErrorTimeMillis = lastErrorTimeMillis;
	}
	public Throwable getLastCreateError() {
		return lastCreateError;
	}
	public void setLastCreateError(Throwable lastCreateError) {
		this.lastCreateError = lastCreateError;
	}
	public long getLastCreateErrorTimeMillis() {
		return lastCreateErrorTimeMillis;
	}
	public void setLastCreateErrorTimeMillis(long lastCreateErrorTimeMillis) {
		this.lastCreateErrorTimeMillis = lastCreateErrorTimeMillis;
	}
	public long getLastCreateStartTimeMillis() {
		return lastCreateStartTimeMillis;
	}
	public void setLastCreateStartTimeMillis(long lastCreateStartTimeMillis) {
		this.lastCreateStartTimeMillis = lastCreateStartTimeMillis;
	}
	public boolean isOracle() {
		return isOracle;
	}
	public void setOracle(boolean isOracle) {
		this.isOracle = isOracle;
	}
	public boolean isMySql() {
		return isMySql;
	}
	public void setMySql(boolean isMySql) {
		this.isMySql = isMySql;
	}
	public boolean isUseOracleImplicitCache() {
		return useOracleImplicitCache;
	}
	public void setUseOracleImplicitCache(boolean useOracleImplicitCache) {
		this.useOracleImplicitCache = useOracleImplicitCache;
	}
	public ReentrantLock getLock() {
		return lock;
	}
	public void setLock(ReentrantLock lock) {
		this.lock = lock;
	}
	public Condition getNotEmpty() {
		return notEmpty;
	}
	public void setNotEmpty(Condition notEmpty) {
		this.notEmpty = notEmpty;
	}
	public Condition getEmpty() {
		return empty;
	}
	public void setEmpty(Condition empty) {
		this.empty = empty;
	}
	public ReentrantLock getActiveConnectionLock() {
		return activeConnectionLock;
	}
	public void setActiveConnectionLock(ReentrantLock activeConnectionLock) {
		this.activeConnectionLock = activeConnectionLock;
	}
	public int getCreateErrorCount() {
		return createErrorCount;
	}
	public void setCreateErrorCount(int createErrorCount) {
		this.createErrorCount = createErrorCount;
	}
	public int getCreatingCount() {
		return creatingCount;
	}
	public void setCreatingCount(int creatingCount) {
		this.creatingCount = creatingCount;
	}
	public int getDirectCreateCount() {
		return directCreateCount;
	}
	public void setDirectCreateCount(int directCreateCount) {
		this.directCreateCount = directCreateCount;
	}
	public long getCreateCount() {
		return createCount;
	}
	public void setCreateCount(long createCount) {
		this.createCount = createCount;
	}
	public long getDestroyCount() {
		return destroyCount;
	}
	public void setDestroyCount(long destroyCount) {
		this.destroyCount = destroyCount;
	}
	public long getCreateStartNanos() {
		return createStartNanos;
	}
	public void setCreateStartNanos(long createStartNanos) {
		this.createStartNanos = createStartNanos;
	}
	public Map&amp;lt;DruidPooledConnection, Object&amp;gt; getActiveConnections() {
		return activeConnections;
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再写一个基本配置继承于上面的properties类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.hisaige.database.config.data;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &amp;quot;spring.datasource.druid&amp;quot;)
public class DataBaseProperties extends DruidProperties {

private String filters;
private String connectionProperties;
//当前配置下暂时用不到
private String dialect;
//当前配置下暂时用不到
private String showSql;
//当前配置下暂时用不到
private String model;
public String getFilters() {
  return filters;
}

public void setFilters(String filters) {
  this.filters = filters;
}

public String getConnectionProperties() {
  return connectionProperties;
}

public void setConnectionProperties(String connectionProperties) {
  this.connectionProperties = connectionProperties;
}

public String getDialect() {
  return dialect;
}

public void setDialect(String dialect) {
  this.dialect = dialect;
}

public String getShowSql() {
  return showSql;
}

public void setShowSql(String showSql) {
  this.showSql = showSql;
}

public String getModel() {
  return model;
}

public void setModel(String model) {
  this.model = model;
}

@Override
public String toString() {
  return &amp;quot;DataBaseProperties [filters=&amp;quot; + filters + &amp;quot;, connectionProperties=&amp;quot; + connectionProperties
        + &amp;quot;, dialect=&amp;quot; + dialect + &amp;quot;, showSql=&amp;quot; + showSql + &amp;quot;, model=&amp;quot; + model + &amp;quot;]&amp;quot;;
}
// druid

}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>linux下git&amp;nodejs&amp;npm安装</title>
      <link>https://hisaige.github.io/post/tool/linux%E4%B8%8Bgitnodejsnpm%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://hisaige.github.io/post/tool/linux%E4%B8%8Bgitnodejsnpm%E5%AE%89%E8%A3%85/</guid>
      
        <description>

&lt;h1&gt;linux下git&amp;nodeJS&amp;npm安装&amp;hugo部署&lt;/h1&gt;

&lt;h2 id=&#34;1-git-安装&#34;&gt;1. git 安装&lt;/h2&gt;

&lt;p&gt;1.安装前检查&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#1.查看git版本,如果能出版本号，说明git已经安装，酌情考虑是否需要重新安装
git --version
#2.卸载git
yum remove git

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载 &lt;a href=&#34;https://github.com/git/git/releases/&#34; title=&#34;git官方下载地址&#34;&gt;git&lt;/a&gt; ，然后解压，编译安装，配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#在local下建立git文件夹 查看当前目录 我的控制台打印出 /usr/local/git 
pwd

# shell下载
wget https://github.com/git/git/archive/v2.23.0.tar.gz

# 解压
tar -xzvf git-2.18.1.tar.gz

#进入解压目录
cd git-2.18.1

#配置git安装路径
./configure prefix=/usr/local/git/git-2.18.1

#编译安装
make &amp;amp;&amp;amp; make install

#注意 如果安装失败，则执行以下指令安装依赖包
yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel 
yum install gcc-c++ perl-ExtUtils-MakeMaker

#最后配置环境变量，将git的运行指令添加到环境变量中
    # 在 /etc/profile 最后一行加入
    export PATH=$PATH:/usr/local/git/bin
 #或
 	echo &amp;quot;export PATH=$PATH:/usr/git/bin&amp;quot; &amp;gt;&amp;gt; /etc/profile

#使配置生效
source /etc/profile

# 查看git版本 
git --version

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-nodejs-npm&#34;&gt;2. nodejs&amp;amp;npm&lt;/h2&gt;

&lt;p&gt;根据需要下载 &lt;a href=&#34;https://nodejs.org/en/download/current/&#34; title=&#34;node官方下载地址&#34;&gt;nodeJs&lt;/a&gt; ，解压。以我的运行环境为例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@localhost node]# ls
node-v12.9.1-linux-x64  node-v12.9.1-linux-x64.tar.xz
[root@localhost node]# cd node-v12.9.1-linux-x64/
[root@localhost node-v12.9.1-linux-x64]# ls
bin  CHANGELOG.md  include  lib  LICENSE  README.md  share
[root@localhost node-v12.9.1-linux-x64]# cd bin
[root@localhost bin]# ls
node  npm  npx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置软连接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@localhost bin]# ln -s /usr/local/node/node-v12.9.1-linux-x64/bin/npm   /usr/local/bin/
[root@localhost bin]# ln -s /usr/local/node/node-v12.9.1-linux-x64/bin/npm   /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功，查看版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@localhost bin]# node -v
v12.9.1
[root@localhost bin]# npm -v
6.10.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-hugo安装及github部署&#34;&gt;3. hugo安装及github部署&lt;/h2&gt;

&lt;p&gt;到 &lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;Hugo Releases&lt;/a&gt; 下载 &lt;code&gt;*Linux-64bit.tar.gz&lt;/code&gt; 压缩包放置到 &lt;code&gt;/usr/local/hugo&lt;/code&gt;下解压，生成一个名为 &lt;code&gt;hugo&lt;/code&gt;的可执行文件。主题本人使用的是 &lt;a href=&#34;https://github.com/xianmin/hugo-theme-jane&#34;&gt;hugo-theme-jane&lt;/a&gt; ，hugo网站创建的具体步骤可参考github上jane的教程说明。在这里主要讲的是github部署。&lt;/p&gt;

&lt;p&gt;首先在github上创建一个名为 &lt;code&gt;xxx.github.io&lt;/code&gt;的仓库，其中 &lt;code&gt;xxx&lt;/code&gt; 为你的github用户名。然后将你hugo目录下的public文件夹通过git上传到github上即可。可参考如下过程:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mkdir /usr/blog/git
$ git clone &#39;刚你创建的空仓库&#39;
$ cd /usr/local/hugo/myblog/public
$ cp -r . /usr/blog/git
$ cd /usr/blog/git/
$ git add .
$ git commit -m &amp;quot;初始化hugo&amp;quot;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在启动hugo生成站点时，需要注意 一般的启动方式&lt;code&gt;hugo server&lt;/code&gt;并不适用于远程部署。&lt;/p&gt;

&lt;p&gt;如果要部署到github，可参考如下编译方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# jane 是主题名，记住 .io/ 中的 / 不能缺少
hugo --theme=jane --baseUrl=https://xxx.github.io/

# 如果hugo指令不能用，可以配置环境变量或者软连接
[root@localhost bin]# ln -s /usr/local/hugo/hugo /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://hisaige.github.io/post/development/linux%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hisaige.github.io/post/development/linux%E5%AD%A6%E4%B9%A0/</guid>
      
        <description>&lt;h1&gt;linux学习&lt;/h1&gt;

</description>
      
    </item>
    
  </channel>
</rss>
